<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<title>Intern: The user guide</title>
		<link rel="shortcut icon" href="images/favicon.png" type="image/png">
		<link rel="stylesheet" href="css/main.css">
		<script src="//use.typekit.net/cbd5jmj.js"></script>
		<script>try{Typekit.load({active:function(){window.fontsActivated=true;window.onTypekitActive&&window.onTypekitActive();}});}catch(e){}</script>
		<script>
(function () {
	var test = document.createElement('b');
	for (var prefix in { '': 1, '-webkit-': 1 }) {
		var position = prefix + 'sticky';
		test.style.position = position;
		if (test.style.position === position) {
			return;
		}
	}
	document.documentElement.classList.add('no-sticky');
})();
		</script>
	</head>
	<body>
		<span role="button" id="showMenu" class="icon-menu"
			aria-controls="tableOfContents"
			aria-expanded="false"
			tabindex="0"
			title="Table of contents">Menu</span>
		<header class="header">
			<div class="wrapper">
				<div class="preTitle">
					<a class="logo" href="https://theintern.github.io/intern/"></a>
					<nav id="mainMenu">
						<ul>
							<li><a href="http://theintern.io">About</a></li>
							<li><a href="https://theintern.github.io/leadfoot/">Leadfoot</a></li>
							<li><a href="https://theintern.github.io/digdug/">Dig Dug</a></li>
							<li><a href="https://github.com/theintern/intern/">GitHub</a></li>
						</ul>
					</nav>
				</div>
				<div id="initialScrollPoint">
					<!-- TODO: Use lunr.js or something for live local search of this page -->
					<form action="https://duckduckgo.com/" role="search">
						<input type="hidden" name="sites" value="theintern.github.io">
						<label class="search">
							<input type="text" name="q">
							<span class="icon-search"></span>
						</label>
					</form>
					<h1 class="title">Intern. The user guide</h1>
				</div>
				<script>
(function () {
	if (window.scrollY === 0 && !location.hash && !document.documentElement.classList.contains('no-sticky')) {
		document.documentElement.style.minHeight = (window.innerHeight + /* $lh */ 32) + 'px';
		var scrollTo = document.getElementById('initialScrollPoint');
		window.scrollTo(window.scrollX, scrollTo.getBoundingClientRect().top);
	}
})();
				</script>
			</div>
		</header>

		<div class="content">
			<div class="wrapper">
				<nav class="nav" id="tableOfContents">
					<ul>
						<li data-id="fundamentals">
							<a href="#fundamentals">Fundamentals</a>
							<ul class="subsections">
								<li data-id="what-is-intern"><a href="#what-is-intern">What is Intern?</a></li>
								<li data-id="system-requirements"><a href="#system-requirements">System requirements</a></li>
								<li data-id="reading-guide"><a href="#reading-guide">Reading this guide</a></li>
							</ul>
						</li>
						<li data-id="getting-started">
							<a href="#getting-started">Getting started</a>
							<ul class="subsections">
								<li data-id="fundamentals-overview"><a href="#fundamentals-overview">Overview</a></li>
								<li data-id="installation"><a href="#installation">Installation</a></li>
								<li data-id="directory-structure"><a href="#directory-structure">Recommended directory structure</a></li>
								<li data-id="terminology"><a href="#terminology">Terminology</a></li>
								<li data-id="conventions"><a href="#conventions">Conventions</a></li>
								<li data-id="first-app"><a href="#first-app">Testing your first app</a></li>
							</ul>
						</li>
						<li data-id="configuration">
							<a href="#configuration">Configuration</a>
							<ul class="subsections">
								<li data-id="common-config"><a href="#common-config">Common configuration</a></li>
								<li data-id="client-config"><a href="#client-config">Client configuration</a></li>
								<li data-id="runner-config"><a href="#runner-config">Test runner configuration</a></li>
							</ul>
						</li>
						<li data-id="interfaces">
							<a href="#interfaces">Test interfaces</a>
							<ul class="subsections">
								<li data-id="interface-overview"><a href="#interface-overview">Overview</a></li>
								<li data-id="interface-object"><a href="#interface-object">The Object interface</a></li>
								<li data-id="interface-tdd"><a href="#interface-tdd">The TDD &amp; BDD interfaces</a></li>
								<li data-id="interface-qunit"><a href="#interface-qunit">The QUnit interface <span class="versionBadge">3.0</span></a></li>
							</ul>
						</li>
						<li data-id="unit-testing">
							<a href="#unit-testing">Unit testing</a>
							<ul class="subsections">
								<li data-id="writing-unit-test"><a href="#writing-unit-test">Writing a unit test</a></li>
								<li data-id="test-lifecycle"><a href="#test-lifecycle">The test lifecycle</a></li>
								<li data-id="async-tests"><a href="#async-tests">Asynchronous tests</a></li>
								<li data-id="skipping-tests"><a href="#skipping-tests">Skipping tests at runtime</a></li>
								<li data-id="testing-commonjs-code"><a href="#testing-commonjs-code">Testing CommonJS modules</a></li>
								<li data-id="testing-global-code"><a href="#testing-global-code">Testing non-modular code</a></li>
								<li data-id="testing-other-module"><a href="#testing-other-module">Testing other transpiled code</a></li>
								<li data-id="testing-cors"><a href="#testing-cors">Testing non-CORS APIs</a></li>
							</ul>
						</li>
						<li data-id="functional-testing">
							<a href="#functional-testing">Functional testing</a>
							<ul class="subsections">
								<li data-id="writing-functional-test"><a href="#writing-functional-test">Writing a functional test</a></li>
								<li data-id="page-objects"><a href="#page-objects">Page objects</a></li>
								<li data-id="native-apps"><a href="#native-apps">Testing native apps</a></li>
								<li data-id="debugging"><a href="#debugging">Debugging</a></li>
							</ul>
						</li>
						<li data-id="webdriver-server">
							<a href="#webdriver-server">Getting a WebDriver server</a>
							<ul class="subsections">
								<li data-id="hosted-selenium"><a href="#hosted-selenium">Cloud hosting</a></li>
								<li data-id="local-selenium"><a href="#local-selenium">Local Selenium</a></li>
								<li data-id="selenium-grid"><a href="#selenium-grid">Selenium Grid</a></li>
							</ul>
						</li>
						<li data-id="execution-modes">
							<a href="#execution-modes">Running tests</a>
							<ul class="subsections">
								<li data-id="browser-client"><a href="#browser-client">The browser client</a></li>
								<li data-id="node-client"><a href="#node-client">The Node.js client</a></li>
								<li data-id="test-runner"><a href="#test-runner">The test runner</a></li>
								<li data-id="custom-args"><a href="#custom-args">Using custom arguments</a></li>
								<li data-id="grunt"><a href="#grunt">Using Grunt</a></li>
								<li data-id="gulp"><a href="#gulp">Using Gulp</a></li>
							</ul>
						</li>
						<li data-id="reporters">
							<a href="#reporters">Getting test results</a>
							<ul class="subsections">
								<li data-id="reporter-overview"><a href="#reporter-overview">Overview</a></li>
								<li data-id="reporter-results"><a href="#reporter-results">Test results reporters</a></li>
								<li data-id="reporter-lcov"><a href="#reporter-lcov">Code coverage reporters</a></li>
								<li data-id="reporter-options"><a href="#reporter-options">Reporter options <span class="versionBadge">3.0</span></a></li>
							</ul>
						</li>
						<li data-id="ci">
							<a href="#ci">Continuous integration</a>
							<ul class="subsections">
								<li data-id="ci-jenkins"><a href="#ci-jenkins">Jenkins</a></li>
								<li data-id="ci-travis"><a href="#ci-travis">Travis CI</a></li>
								<li data-id="ci-teamcity"><a href="#ci-teamcity">TeamCity</a></li>
								<li data-id="ci-codeship"><a href="#ci-codeship">Codeship</a></li>
								<li data-id="ci-bamboo"><a href="#ci-bamboo">Bamboo</a></li>
							</ul>
						</li>
						<li data-id="customisation">
							<a href="#customisation">Customisation</a>
							<ul class="subsections">
								<li data-id="custom-interfaces"><a href="#custom-interfaces">Custom interfaces</a></li>
								<li data-id="custom-executors"><a href="#custom-executors">Custom executors <span class="versionBadge">3.0</span></a></li>
								<li data-id="custom-reporters"><a href="#custom-reporters">Custom reporters</a></li>
							</ul>
						</li>
						<li data-id="internals">
							<a href="#internals">Internals</a>
							<ul class="subsections">
								<li data-id="suite-object"><a href="#suite-object">The Suite object</a></li>
								<li data-id="test-object"><a href="#test-object">The Test object</a></li>
							</ul>
						</li>
						<li data-id="community">
							<a href="#community">Community</a>
							<ul class="subsections">
								<li data-id="getting-help"><a href="#getting-help">Getting help</a></li>
								<li data-id="contributing"><a href="#contributing">Contributing</a></li>
							</ul>
						</li>
						<li data-id="faq">
							<a href="#faq">FAQ</a>
							<ul class="subsections">
								<li data-id="modifier-keys"><a href="#modifier-keys">Using Modifier Keys</a></li>
								<li data-id="test-page-open"><a href="#test-page-open">Keeping the Test Page Open</a></li>
								<li data-id="multiple-browsers"><a href="#multiple-browsers">Testing with Multiple Browsers</a></li>
							</ul>
						</li>
					</ul>

					<p class="support"><a href="https://sitepen.com/support/index.html">Commercial support</a></p>
				</nav>

				<main class="main" id="main">
					<article>
						<div class="a" id="fundamentals"></div>
						<h2 data-id="fundamentals">Fundamentals</h2>

						<div class="a half" id="what-is-intern"></div>
						<h3 data-id="what-is-intern">What is Intern?</h3>

						<p>Intern is a complete framework for testing Web sites and applications. It’s built around standards like WebDriver and was designed from the ground up to be the most powerful, flexible, and reliable JavaScript testing system in the world.</p>

						<p>Intern can test all sorts of things:</p>

						<ul>
							<li>Plain JavaScript code, in any module format (or no module format!)</li>
							<li>Web pages generated by server-side languages (like Java, PHP, or Ruby)</li>
							<li>Native or hybrid iOS, Android, and Firefox OS applications</li>
						</ul>

						<p>Intern is minimally prescriptive and enforces only a basic set of best practices designed to ensure your tests stay maintainable over time. Its extensible architecture allows you to write custom test interfaces, executors, and reporters to influence how your tests run &amp; easily integrate with your existing coding environment.</p>

						<p>Intern also comes with Grunt tasks so it can be quickly added to existing Grunt-based workflows, and is designed to work out-of-the-box with many popular continuous integration services like Jenkins and Travis CI.</p>

						<p>Intern is used by companies large and small, including some you may have heard of, like Aerohive Networks, Esri, HSBC, IBM, ING, Intuit, Marriott, Mozilla, Stripe, and Twitter. We hope you’ll enjoy working with it too!</p>

						<h4>Who is Intern best for?</h4>

						<p>Intern is best for development teams that want a complete, flexible, <a href="http://www.w3.org/TR/webdriver/">standards-based</a>, high-quality testing solution that Just Works. It’s best for testing JavaScript code, but it is also an excellent tool for testing server-generated Web pages or native mobile apps. Its built-in support for <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source maps</a> makes it uniquely well-suited for developers that compile their code to JavaScript from another language, such as TypeScript, or that run tests against production-ready built/minified code.</p>

						<p>Intern is excellent for teams that are just beginning to write tests; its built-in <a href="#reporter-lcov">code coverage analysis</a> makes thorough testing fast and precise, and its <a href="#writing-functional-test">functional testing system</a> enables testing of highly procedural code that’s otherwise impossible to test.</p>

						<p>Intern is a great choice if you’re hoping to transition away from your current testing library but already have a lot of tests, since its <a href="#interface-overview">extensible interfaces</a> make it possible to transition without needing to rewrite tests or learn a totally new set of APIs.</p>

						<p>Intern’s execution model is well-suited to those that follow a test-last development approach and want to prevent regressions using continuous integration. It has also been used very successfully by teams that follow a test-driven development approach.</p>

						<p>Finally, because of its strong architectural patterns, conventions, and expansive feature set, Intern is well-suited for testing extremely large, “enterprise-level” applications that must be maintained by large teams of developers with varying skill levels.</p>

						<div class="a half" id="system-requirements"></div>
						<h3 data-id="system-requirements">System requirements</h3>

						<p>Intern can be used to run unit tests in any of the following environments:</p>

						<table>
							<tr>
								<td>Android Browser</td>
								<td>4.1+</td>
							</tr>
							<tr>
								<td>Chrome</td>
								<td>31+</td>
							</tr>
							<tr>
								<td>Firefox</td>
								<td>17+</td>
							</tr>
							<tr>
								<td>Internet Explorer</td>
								<td>9+</td>
							</tr>
							<tr>
								<td>Node.js</td>
								<td>0.10+</td>
							</tr>
							<tr>
								<td>Opera</td>
								<td>26+</td>
							</tr>
							<tr>
								<td>Safari (iOS)</td>
								<td>6.1+</td>
							</tr>
							<tr>
								<td>Safari (Mac OS)</td>
								<td>6.0+</td>
							</tr>
						</table>

						<p>Intern can be used to run functional tests in any of the following environments:</p>

						<table>
							<tr>
								<td>Android (browser, hybrid, native)</td>
								<td>4.1+</td>
							</tr>
							<tr>
								<td>Chrome</td>
								<td>31+</td>
							</tr>
							<tr>
								<td>Firefox</td>
								<td>17+</td>
							</tr>
							<tr>
								<td>Internet Explorer</td>
								<td>8+</td>
							</tr>
							<tr>
								<td>iOS (browser, hybrid, native)</td>
								<td>6.1+</td>
							</tr>
							<tr>
								<td>Opera</td>
								<td>26+</td>
							</tr>
							<tr>
								<td>Safari (Mac OS)</td>
								<td>6+</td>
							</tr>
						</table>

						<p>All other environments are not currently officially supported, but should work as long as they correctly implement EcmaScript 5 (for unit tests) and/or WebDriver (for functional tests).</p>

						<p>In order to execute functional tests, or to execute tests against multiple browsers at the same time, Intern also requires Node.js 0.10+ plus a WebDriver-compatible server.</p>

						<p>The following WebDriver servers are compatible with Intern:</p>

						<table>
							<tr>
								<td>Appium</td>
								<td>1.3.0+</td>
							</tr>
							<tr>
								<td>ChromeDriver</td>
								<td>2.9+</td>
							</tr>
							<tr>
								<td>FirefoxDriver (Selenium)</td>
								<td>2.41.0+</td>
							</tr>
							<tr>
								<td>InternetExplorerDriver (Selenium)</td>
								<td>2.41.0+</td>
							</tr>
							<tr>
								<td>ios-driver</td>
								<td>0.6.6+</td>
							</tr>
							<tr>
								<td>SafariDriver (Selenium)</td>
								<td>2.41.0+</td>
							</tr>
							<tr>
								<td>Selendroid</td>
								<td>0.9.0+</td>
							</tr>
						</table>

						<p>Intern also has built-in support for cloud hosted services from <a href="https://browserstack.com">BrowserStack</a>, <a href="https://saucelabs.com">Sauce Labs</a>, and <a href="https://testingbot.com">TestingBot</a>.</p>

						<div class="a half" id="reading-guide"></div>
						<h3 data-id="reading-guide">Reading this guide</h3>

						<p>Throughout this guide, you will find certain pieces of information are called out specifically, as we have found them to be especially important or problematic for users.</p>

						<p>Features marked with a <span class="versionBadge">3.0</span> indicate that the feature is only available starting in that particular version of Intern.</p>

						<aside class="tip">
							<p>Sections that look like this contain advanced tips and tricks that can help you get the most out of Intern.</p>
						</aside>

						<aside class="deprecated">
							<p>Sections that look like this tell you about functionality that is deprecated and will be removed from a future version of Intern.</p>
						</aside>

						<aside class="whatAreYouCrazy">
							<p>Sections that look like this tell you about dangerous anti-patterns that can break, slow down, or make your code less maintainable.</p>
						</aside>

						<p>Later sections of this guide are designed to be built upon knowledge presented in earlier parts. If you jump into the middle and feel confused, step back a section or two until you find the information you need to move forward. We also accept <a href="https://github.com/theintern/intern/pulls?q=is%3Aopen+label%3Adocumentation+is%3Apr">pull requests</a> to the <a href="https://github.com/theintern/intern/tree/gh-pages">documentation source</a> in order to improve its flow and clarity.</p>
					</article>

					<article>
						<div class="a" id="getting-started"></div>
						<h2 data-id="getting-started">Getting started</h2>

						<div class="a half" id="fundamentals-overview"></div>
						<h3 data-id="fundamentals-overview">Overview</h3>

<!--TODO: Diagram
						<figure>
							<img src="http://placekitten.com/1000/608">
							<figcaption>The architecture of Intern</figcaption>
						</figure>-->

						<p>Intern provides two strategies for automated testing: unit testing and functional testing.</p>

						<p><dfn>Unit testing</dfn> works by executing a piece of code directly and inspecting the result. For example, calling a function and then checking that it returns an expected value is a form of unit testing. This is the most common and most useful form of testing for day-to-day development, since it’s very fast and allows very small units of code to be tested in isolation. However, unit tests are limited to only testing certain testable code designs, and can also be limited by the constraints of the execution environment (like browser sandboxes).</p>

						<p><dfn>Functional testing</dfn> works by issuing commands to a device that mimic actual user interactions. Once an interaction has occurred, these tests verify that the expected information is displayed by the user interface. Because these interactions come from outside the application being tested, they are not restricted by the execution environment. They also allow application code to be treated as a black box, which means functional tests can be written to test pages and applications written in any language. Because functional tests don’t call any APIs directly, code that is unable to be unit tested can still be successfully exercised. Functional tests allow the automation of UI &amp; integration testing that would otherwise need to be performed manually.</p>

						<p>By understanding &amp; combining both of these testing strategies when testing an application, it becomes possible to effectively automate nearly all of the QA process, enabling much faster development cycles and significantly reducing software defects.</p>

						<div class="a half" id="installation"></div>
						<h3 data-id="installation">Installation</h3>

						<p>Intern can be installed simply by running <kbd>npm install intern</kbd>.</p>


						<div class="a half" id="directory-structure"></div>
						<h3 data-id="directory-structure">Recommended directory structure</h3>

						<p>While Intern can be used to test code using nearly any directory structure, if you are starting a new project or have the ability to modify the directory structure of your existing project, a few small changes can help make Intern integration a lot easier.</p>

						<p>The recommended directory structure for a front-end or front+back-end project using Intern looks like this:</p>

						<pre>project_root/
	dist/         – (optional) Built code; mirrors the `src` directory
	node_modules/ – Node.js dependencies, including Intern
		intern/
	src/          – Front-end source code (+ browser dependencies)
		app/        – Your application code
		index.html  – Your application entry point
	tests/        – Intern tests
		functional/ – Functional tests
		support/    – Test support files
		              (custom interfaces, reporters, mocks, etc.)
		unit/       – Unit tests
		intern.js   – Intern configuration</pre>

						<p>Using this directory structure provides a few benefits:</p>

						<ul>
							<li>It lets you easily switch from testing source and built code simply by changing the location of your packages from <kbd>src</kbd> to <kbd>dist</kbd> in your Intern configuration</li>
							<li>It lets you use the default loader <code>baseUrl</code> configuration setting without worrying about path differences between Node.js and browser</li>
							<li>It adds another layer of assurance that your tests and other private server-side code won’t be accidentally deployed along with the rest of your application</li>
						</ul>

						<div class="a half" id="terminology"></div>
						<h3 data-id="terminology">Terminology</h3>

						<p>Intern uses certain standard terminology in order to make it easier to understand each part of the system.</p>

						<ul>
							<li>An <dfn><a href="#writing-unit-test">assertion</a></dfn> is a function call that verifies that an expression (like a variable or function call) returns an expected, correct, value (e.g. <code>assert.isTrue(someVariable, 'someVariable should be true')</code>)</li>
							<li>A <dfn>test <a href="#interfaces">interface</a></dfn> is a programming interface for registering tests with Intern</li>
							<li>A <dfn>test case</dfn> (or, just <dfn>test</dfn>) is a function that makes calls to application code and makes assertions about what it should have done</li>
							<li>A <dfn>test suite</dfn> is a collection of tests (and, optionally, sub–test-suites) that are related to each other in some logical way</li>
							<li>A <dfn>test module</dfn> is a JavaScript module, usually in <a href="#amd">AMD format</a>, that contains test suites</li>
						</ul>

						<p>These pieces can be visualized in a hierarchy, like this:</p>

						<ul>
							<li
								>test module
								<ul>
									<li
										>test suite
										<ul>
											<li
												>test suite
												<ul>
													<li
														>test case
														<ul>
															<li>assertion</li>
															<li>assertion</li>
															<li>…</li>
														</ul>
													</li>
													<li>…</li>
												</ul>
											</li>
											<li
												>test case
												<ul>
													<li>assertion</li>
													<li>assertion</li>
													<li>…</li>
												</ul>
											</li>
											<li>…</li>
										</ul>
									</li>
									<li>test suite</li>
									<li>…</li>
								</ul>
							</li>
							<li>test module</li>
							<li>…</li>
						</ul>

						<div class="a half" id="conventions"></div>
						<h3 data-id="conventions">Conventions</h3>

						<p>Intern follows certain conventions in order to make testing easier and more reliable. Understanding these fundamental concepts will help you get the most out of testing with Intern.</p>

						<h4>Asynchronous operations</h4>

						<p>Intern always uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> objects whenever an asynchronous operation needs to occur. All <a href="#suite-object">suite</a>, <a href="#test-object">test</a>, and <a href="#custom-reporters">reporter</a> functions can return a Promise, which will pause the test system until the Promise resolves (or until a timeout occurs, whichever happens first).</p>

						<h4 id="amd">Module loader &amp; format</h4>

						<p>Intern is built on top of a standard <abbr title="Asynchronous Module Definition">AMD</abbr> loader, which means that its modules are also normally written in the AMD module format. Using an AMD loader instead of something like the built-in Node.js loader + Browserify is critical to provide a highly stable and flexible testing system, because AMD is the only stable standard for module loading that has all of these traits:</p>

						<ul>
							<li>Allows modules to be written for the browser without <em>requiring</em> an intermediate compilation step;</li>
							<li>Allows modules and other assets to be <em>asynchronously</em> or <em>conditionally</em> resolved by writing simple <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">loader plugins</a>;</li>
							<li>Allows “hard-coded” dependencies of modules under test to be <a href="https://www.sitepen.com/blog/2014/07/14/mocking-data-with-intern/#mocking-amd-dependencies">mocked</a> without messing with the internals of the module loader</li>
						</ul>

						<p>For users that are only familiar with Node.js modules, AMD modules are exactly the same with one extra line of wrapper code to enable asynchronous loading:</p>

						<pre><code class="javascript">define(function (require, exports, module) {
/* Node.js module code here! */
});</code></pre>

						<aside class="tip"><p>Because the AMD standard includes the ability to run loader plugins, it’s not necessary for your test modules to be written as AMD modules if you don’t want. Just write a loader plugin that understands the module format you prefer and you’re ready to go!</p></aside>

						<aside class="tip"><p>Once the <a href="http://jrburke.com/2015/02/13/how-to-know-when-es-modules-are-done/">outstanding issues with native ES modules</a> have been addressed, and a native module loader with equivalent capabilities to a standard AMD loader is available on all the <a href="#system-requirements">platforms supported by Intern</a>, Intern will be updated to use the native ES module format.</p></aside>

<!-- TODO: Use these templates for part of the document or remove them
						<figure>
							<pre><code class="javascript">function TODO() {}</code></pre>
							<figcaption>TODO</figcaption>
						</figure>

						<div class="codeMirror">
							<pre><code class="javascript">function TODO() {}</code></pre>
							<pre class="align-bottom"><samp class="javascript">output</samp></pre>
						</div>
-->

						<div class="a half" id="first-app"></div>
						<h3 data-id="first-app">Testing your first app</h3>

						<p>In order to quickly get started with Intern, we’ve created a basic <a href="https://github.com/theintern/intern-tutorial">tutorial</a> that walks through the steps required to install, configure, and run basic tests against a very simple demo application.</p>

						<p>Once you’ve run through the tutorial, you may also want to look at some of the <a href="https://github.com/theintern/intern-examples">example integrations</a> for popular libraries and frameworks if you are using AngularJS, Backbone.js, Dojo, Ember, or jQuery.</p>

						<aside class="whatAreYouCrazy"><p>Some of the example integrations are outdated and don’t represent modern best practices when using Intern. We’d love it if you’d <a href="https://github.com/theintern/intern-examples/fork">submit your own examples</a> following the patterns outlined in this document to make Intern easier to use for new users!</p></aside>

						<p>After that, continue reading the user guide to learn about all the advanced functionality available within Intern that you can use test your own code better and faster!</p>
					</article>

					<article>
						<div class="a" id="configuration"></div>
						<h2 data-id="configuration">Configuration</h2>

						<div class="a half" id="common-config"></div>
						<h3 data-id="common-config">Common configuration</h3>

						<p>Intern’s configuration files are actually <a href="http://dojotoolkit.org/documentation/tutorials/1.10/modules/">standard AMD modules</a> that export a configuration object. This allows simple inheritance of parent configurations and enables test configurations to be generated programmatically at runtime.</p>
						<p>The configuration file is specified using the <a href="#execution-modes"><kbd>config</kbd> argument</a> on the command-line (for Node.js) or the <kbd>config</kbd> argument in the URL query-string (for browsers).</p>

						<aside class="tip"><p>Take a look at the <a href="https://github.com/theintern/intern/blob/master/tests/example.intern.js">example configuration file</a> that comes with Intern to learn what a valid configuration looks like.</p></aside>

						<p>The following configuration options are common to <a href="#execution-modes">all execution modes</a> in Intern:</p>

						<table class="api">
							<thead>
								<tr>
									<th>Option</th>
									<th>Type</th>
									<th>Default</th>
								</tr>
							</thead>
							<tr>
								<th scope="row"><a href="#option-bail">bail</a> <span class="versionBadge">3.1</span></th>
								<td>If this value is set to <code class="javascript">true</code>, a failing test will cause all following tests in all suites to be skipped.</td>
								<td><code class="javascript">false</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-basePath">basePath</a> <span class="versionBadge">3.0</span></th>
								<td>The common base path for all files that need to be loaded during testing.</td>
								<td><code class="javascript">process.cwd()</code> (Node.js)<br><code class="javascript">'node_modules/intern/../../'</code> (browser)</td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-coverageVariable">coverageVariable</a> <span class="versionBadge">3.0</span></th>
								<td>The name of the global variable used to store and retrieve code coverage data.</td>
								<td><code class="javascript">'__internCoverage'</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-defaultTimeout">defaultTimeout</a> <span class="versionBadge">3.0</span></th>
								<td>The amount of time, in milliseconds, an asynchronous test can take before it is considered timed out.</td>
								<td><code class="javascript">30000</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-excludeInstrumentation">excludeInstrumentation</a></th>
								<td>A boolean <span class="versionBadge">3.0</span> or regular expression matching paths to exclude from code coverage.</td>
								<td><code class="javascript">null</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-grep">grep</a></th>
								<td>A regular expression that filters which tests should run.</td>
								<td><code class="javascript">/.*/</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-loader">loaderOptions</a> <span class="versionBadge">3.0</span><br><a href="#option-loader">loader</a> <span class="versionBadge">2.0</span></th>
								<td>Configuration options for the AMD loader.</td>
								<td><code class="javascript">{ … }</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-useLoader">loaders</a> <span class="versionBadge">3.0</span><br><a href="#option-useLoader">useLoader</a> <span class="versionBadge">2.0</span></th>
								<td>An alternative module loader to use in place of the built-in AMD loader.</td>
								<td><code class="javascript">{}</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-reporters">reporters</a></th>
								<td>An array of reporters to use to report test results.</td>
								<td><code class="javascript">[ 'Runner' ]</code> (runner)<br><code class="javascript">[ 'Console' ]</code> (client)</td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-suites">suites</a></th>
								<td>An array of unit test module IDs to load. These may include glob patterns. <span class="versionBadge">3.1</span></td>
								<td><code class="javascript">[]</code></td>
							</tr>
						</table>

						<div class="a half" id="option-bail"></div>
						<h4>bail (boolean) <span class="versionBadge">3.1</span></h4>

						<p>The <code>bail</code> option controls Intern's “fail fast” behavior. When <code>bail</code> is set to <code class="javascript">true</code> and a test fails, all remaining tests, both unit and functional, will be skipped. Other than the cleanup methods for the failing test and its containing suite, no other test or suite lifecycle methods (<code class="javascript">setup/before</code>, <code class="javascript">beforeEach</code>, <code class="javascript">afterEach</code>, <code class="javascript">teardown/after</code>) will be run.</p>

						<div class="a half" id="option-basePath"></div>
						<h4>basePath (string) <span class="versionBadge">3.0</span></h4>

						<p>The common base path for all files that need to be loaded during testing. If <code>basePath</code> is specified using a relative path, that path is resolved differently depending upon where Intern is executing:</p>

						<ul>
							<li>In Node.js, <code>basePath</code> is resolved relative to <code>process.cwd()</code></li>
							<li>In a browser with an <a href="#option-baseUrl"><code>initialBaseUrl</code></a> argument in the query-string, <code>basePath</code> is resolved relative to <code>initialBaseUrl</code></li>
							<li>In a browser with no <code>initialBaseUrl</code> argument, <code>basePath</code> is resolved relative to two directories above the Intern directory (i.e. <code>node_modules/intern/../../</code>)</li>
						</ul>

						<p>If <code>basePath</code> is not explicitly provided, it is set to <code>.</code> and is resolved according to the rules above.</p>

						<aside class="whatAreYouCrazy"><p><code>basePath</code> is the directory that is served by the test runner’s instrumenting proxy HTTP server. If it is not set properly for your application, the test runner will not work correctly.</p></aside>

						<div class="a half" id="option-coverageVariable"></div>
						<h4>coverageVariable (string) <span class="versionBadge">3.0</span></h4>

						<p>The name of the global variable used to store and retrieve code coverage data. Change this only if you have code that is pre-instrumented by a compatible version of Istanbul with a different global variable name.</p>

						<div class="a half" id="option-defaultTimeout"></div>
						<h4>defaultTimeout (number) <span class="versionBadge">3.0</span></h4>

						<p>The amount of time, in milliseconds, an asynchronous test can run before it is considered timed out. By default this value is 30 seconds.</p>

						<p>Timeouts can be set for an individual test by setting the <code>timeout</code> property of the test, or for all tests within a test suite by setting the <code>timeout</code> property of the suite.</p>

						<div class="a half" id="option-excludeInstrumentation"></div>
						<h4>excludeInstrumentation (RegExp | boolean <span class="versionBadge">3.0</span>)</h4>

						<p>The <code>excludeInstrumentation</code> option can be either a regular expression or the boolean value <code>true</code>.</p>

						<p>As a boolean <code>true</code>, completely disables code instrumentation.</p>

						<p>As a regular expression, a regular expression matching paths to exclude from code coverage. The regular expression matches the path-part of URLs (starting from the end of <a href="#option-proxyUrl">proxyUrl</a>, excluding any trailing slash) or paths (starting from the end of <code>process.cwd()</code>) that should not be instrumented for code coverage during testing in browsers and the Node.js client.</p>

						<p>This option should be used when you want to exclude dependencies from being reported in your code coverage results. (Intern code—that is, anything that loads from {{proxyUrl}}/__intern/—is always excluded from code coverage results.) For example, to exclude tests and Node.js dependencies from being reported in your application’s code coverage analysis:</p>

						<pre><code class="javascript">{
	excludeInstrumentation: /^(?:tests|node_modules)\//
}</code></pre>

						<aside class="tip"><p>If you are running Intern 2 on Windows, you will need to use <code>[\\/]</code> instead of <code>\/</code> to match the path separator used by that OS. In Intern 3, forward-slashes should always be used regardless of platform.</p></aside>

						<div class="a half" id="option-grep"></div>
						<h4>grep (RegExp)</h4>

						<p>A regular expression that filters which tests should run. <code>grep</code> should be used whenever you want to run only a subset of all available tests.</p>

						<p>When using <code>grep</code>, its value is matched against the ID of each registered test, and tests that don’t match are skipped with a skip message of “grep”.</p>

						<p>The ID of a test is a concatenation of the test’s name, plus the names of its parent suites, separated by <code>' - '</code>. In other words, a test registered like this:</p>

						<pre><code class="javascript">tdd.suite('FooComponent', function () {
	tdd.test('startup', function () {
		// …
	});
});</code></pre>

						<p>…would have the ID <code>'FooComponent - startup'</code>. In this case, all of the following <code>grep</code> values would match and cause this test to run:</p>

						<ul>
							<li><code class="javascript">/FooComponent/</code></li>
							<li><code class="javascript">/startup/</code></li>
							<li><code class="javascript">/FooComponent - startup/</code></li>
							<li><code class="javascript">/foocomponent/i</code></li>
							<li><code class="javascript">/start/</code></li>
						</ul>

						<p>The following <code>grep</code> values would <em>not</em> match and cause this test to be skipped:</p>

						<ul>
							<li><code class="javascript">/BarComponent/</code> – “BarComponent” is not in the full name of the test</li>
							<li><code class="javascript">/foocomponent/</code> – this regular expression is case sensitive</li>
							<li><code class="javascript">/^startup/</code> – the full ID of the test is matched, not just the name part</li>
						</ul>

						<div class="a half" id="option-loader"></div>
						<h4>loaderOptions (Object) <span class="versionBadge">3.0</span> / loader (Object) <span class="versionBadge">2.0</span></h4>

						<p>Configuration options for the module loader. Any <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md">configuration options</a> that are supported by the active loader can be used here. By default, the <a href="https://github.com/dojo/dojo2">Dojo 2</a> AMD loader is used; this can be changed to another loader that provides an AMD-compatible API with <a href="#config-useLoader"><code>loaders</code></a>.</p>

						<p>AMD configuration options supported by the built-in loader are <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#map-"><code>map</code></a>, <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#packages-"><code>packages</code></a>, and <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#paths-"><code>paths</code></a>.</p>

						<p><span class="versionBadge">3.0</span> If <a href="https://github.com/amdjs/amdjs-api/blob/master/CommonConfig.md#baseurl-"><code>baseUrl</code></a> is not explicitly defined, it is automatically set to be equivalent to the <a href="#option-basePath"><code>basePath</code></a>. Relative <code>baseUrl</code>s are relative to <code>basePath</code>.</p>

						<p>When following the <a href="#directory-structure">recommended directory structure</a>, no extra loader configuration is needed.</p>

						<p>If you are testing an AMD application and need to use stub modules for testing, the <code>map</code> configuration option is the correct way to do this:</p>

						<pre><code class="javascript">{
	loaderOptions: {
		map: {
			app: {
				// When any module inside 'app' tries to load 'app/foo',
				// it will receive 'tests/stubs/app/foo' instead
				'app/foo': 'tests/stubs/app/foo'
			}
		}
	}
}</code></pre>

						<div class="a half" id="option-useLoader"></div>
						<h4>loaders (Object) <span class="versionBadge">3.0</span> / useLoader (Object) <span class="versionBadge">2.0</span></h4>

						<p>An alternative module loader to use in place of the built-in AMD loader. When <code>loaders</code> is specified, Intern will swap out the built-in loader with the loader you’ve specified before loading reporters and test modules.</p>

						<p>The alternative loader you use must implement the AMD API and must support the <code>baseUrl</code>, <code>map</code>, and <code>packages</code> configuration options.</p>

						<p>There are two different keys that may be specified so that the correct path to the loader can be provided in each environment:</p>

						<ul>
							<li><code>host-node</code> specifies the loader to use in Node.js. This should be a Node.js module ID.</li>
							<li><code>host-browser</code> specifies the loader to use in browsers. This should be a path or URL to a script file.</li>
						</ul>

						<p>In Intern 2, loader paths are relative to the directory where Intern is installed. In Intern 3, loader paths are relative to <a href="#option-basePath"><code>basePath</code></a>.</p>

						<p>For example, to use a copy of RequireJS installed to the same project as Intern:</p>

						<pre><code class="javascript">loaders: {
	'host-node': 'requirejs',
	'host-browser': 'node_modules/requirejs/require.js'
}</code></pre>

						<aside class="whatAreYouCrazy"><p>When using RequireJS in Node.js, you <em>must</em> use <code class="javascript">'requirejs'</code>, which actually loads <code>r.js</code>. The file <code>require.js</code> is for Web browsers <em>only</em> and will not work.</aside>

						<div class="a half" id="option-reporters"></div>
						<h4>reporters (Array&lt;Object <span class="versionBadge">3.0</span> | string>)</h4>

						<p>An array of reporters to use to report test results. Reporters in this list can either be <a href="#reporters">built-in reporter names</a> (like <code class="javascript">'Console'</code> or <code class="javascript">'JUnit'</code>), or absolute AMD module IDs (like <code class="javascript">'tests/support/customReporter'</code>) when using <a href="#custom-reporters">custom reporters</a>.</p>

						<p><span class="versionBadge">3.0</span> Reporters can also be configured by passing an object with extra configuration options valid for the given reporter. In this case, the ID of the reporter should be given by the <code>id</code> key of the reporter configuration:</p>

						<pre><code class="javascript">{
	reporters: [
		{ id: 'JUnit', filename: 'report.xml' }
	]
}</code></pre>

						<p>If reporters are not specified in the configuration, Intern will pick defaults that are most suitable for the current execution mode.</p>

						<aside class="tip"><p>In Intern 2, reporter IDs are all lowercase. In Intern 3, reporter IDs are UpperCamelCase (because they are now constructors).</p></aside>

						<div class="a half" id="option-suites"></div>
						<h4>suites (Array&lt;string>)</h4>

						<p>An array of unit test module IDs to load. For example:</p>

						<pre><code class="javascript">{
	suites: [
		'tests/unit/foo',
		'tests/unit/bar'
	]
}</code></pre>

						<p>Suite specifiers may also include glob patterns using syntax supported by <a href="https://github.com/isaacs/node-glob#glob-primer">node-glob</a>:</p>

						<pre><code class="javascript">{
	suites: [
		'tests/unit/foo/*',
		'tests/unit/{bar,baz}/*'
	]
}</code></pre>

						<p>Like simple suite specifiers, specifiers with glob patterns refer to module IDs, not file paths. Glob patterns must resolve to individual test modules, not packages. For example, given the following project structure, <code>'tests/u*'</code> would not be a valid glob, but <code>'tests/unit/f*'</code> would be:</p>

						<pre>project_root/
	tests/
		unit/
			foo.js
			bar.js
		intern.js</pre>

						<aside class="whatAreYouCrazy"><p>Glob expressions aren’t evaluated in module IDs involving loader plugins, so the following won’t work: 'dojo/node!cjsmodules/*'.</p></aside>

						<aside class="tip"><p>When running tests with <code>client.html</code>, tests must be served by the Intern proxy to use globbing.</p></aside>

						<p><code>suites</code> can be set to <code class="javascript">null</code> to skip loading the unit testing system when in runner mode. From the command line, this is done by passing the argument <code>suites=</code>.</p>

						<div class="a half" id="client-config"></div>
						<h3 data-id="client-config">Client configuration</h3>

						<p>There are currently no options that only apply when running in client mode.</p>

						<div class="a half" id="runner-config"></div>
						<h3 data-id="runner-config">Test runner configuration</h3>

						<p>Certain configuration options only apply when in runner mode. These options are ignored when running in client mode.</p>

						<table class="api">
							<thead>
								<tr>
									<th>Option</th>
									<th>Type</th>
									<th>Default</th>
								</tr>
							</thead>
							<tr>
								<th scope="row"><a href="#option-capabilities">capabilities</a></th>
								<td>Default capabilities for all test environments.</td>
								<td>
									<code class="javascript">{ name: configModuleId,<br>  'idle-timeout': 60 }</code>
								</td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-environments">environments</a></th>
								<td>An array of capabilities objects, one for each desired test environment.</td>
								<td><code class="javascript">[]</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-environmentRetries">environmentRetries</a> <span class="versionBadge">3.0</span></th>
								<td>The number of times to retry creating a session for a remote environment.</td>
								<td><code class="javascript">3</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-functionalSuites">functionalSuites</a></th>
								<td>An array of functional test module IDs to load. These may include glob patterns.</td>
								<td><code class="javascript">[]</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-leaveRemoteOpen">leaveRemoteOpen</a> <span class="versionBadge">3.0</span></th>
								<td>Leaves the remote environment running at the end of the test run.</td>
								<td><code class="javascript">false</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-maxConcurrency">maxConcurrency</a></th>
								<td>The maximum number of environments to test simultaneously.</td>
								<td><code class="javascript">3</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-proxyOnly">proxyOnly</a> <span class="versionBadge">3.0</span></th>
								<td>Starts Intern’s instrumenting HTTP proxy but performs no other work.</td>
								<td><code class="javascript">false</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-proxyPort">proxyPort</a></th>
								<td>The port where the Intern HTTP server will listen for requests.</td>
								<td><code class="javascript">9000</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-proxyUrl">proxyUrl</a></th>
								<td>The external URL to the Intern HTTP server.</td>
								<td><code class="javascript">'http://localhost:9000/'</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-runnerClientReporter">runnerClientReporter</a> <span class="versionBadge">3.0</span></th>
								<td>The reporter used to send data from the unit testing system back to the test runner.</td>
								<td><code class="javascript">{ id: 'WebDriver' }</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-tunnel">tunnel</a></th>
								<td>The tunnel to use to establish a WebDriver server for testing.</td>
								<td><code class="javascript">'NullTunnel'</code></td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-tunnelOptions">tunnelOptions</a></th>
								<td>Options to pass to the WebDriver server tunnel.</td>
								<td><code class="javascript">{}</code></td>
							</tr>
						</table>

						<div class="a half" id="option-capabilities"></div>
						<h4>capabilities (Object)</h4>

						<p>Default capabilities for all test environments. These baseline capabilities are extended for each environment by the <a href="#option-environments"><code>environments</code></a> array.</p>

						<p>Different services like BrowserStack and Sauce Labs may have different sets of available capabilities. In order for Intern to work correctly, it’s important that you use the appropriate capabilities for WebDriver server you are interacting with:</p>

						<ul>
							<li><a href="https://code.google.com/p/selenium/wiki/DesiredCapabilities">Selenium capabilities</a></li>
							<li><a href="https://www.browserstack.com/automate/capabilities">BrowserStack capabilities</a></li>
							<li><a href="https://docs.saucelabs.com/reference/test-configuration/#webdriver-api">Sauce Labs capabilities</a> and <a href="https://saucelabs.com/platforms">environments</a></li>
							<li><a href="https://testingbot.com/support/other/test-options">TestingBot capabilities</a> and <a href="https://testingbot.com/support/getting-started/browsers.html">environments</a></li>
						</ul>

						<p>Extra <a href="https://sites.google.com/a/chromium.org/chromedriver/capabilities">options for ChromeDriver</a> are specified on the <code>chromeOptions</code> capability.</p>

						<p>Intern will automatically fill certain capabilities fields in order to provide better feedback within cloud service dashboards:</p>

						<ul>
							<li><code>name</code> will be set to the ID of the configuration file being used</li>
							<li><code>build</code> will be set to the commit ID from the <code>TRAVIS_COMMIT</code> and <code>BUILD_TAG</code> environment variables, if either exists</li>
						</ul>

						<div class="a half" id="option-environments"></div>
						<h4>environments (Array&lt;Object>)</h4>

						<p>An array of capabilities objects, one for each desired test environment. The same options from <a href="#option-capabilities">capabilities</a> are used for each environment specified in the array. To delete an option from the default capabilities, explicitly set its value to <code class="javascript">undefined</code>.</p>

						<p>If arrays are provided for <code>browserName</code>, <code>version</code>, <code>platform</code>, or <code>platformVersion</code>, all possible option permutations will be generated. For example:</p>

						<pre><code class="javascript">{
	environments: [
		{
			browserName: 'chrome',
			version: [ '23', '24' ],
			platform: [ 'Linux', 'Mac OS 10.8' ]
		}
	]
}</code></pre>

						<p>This configuration will generate 4 environments: Chrome 23 on Linux, Chrome 23 on Mac OS 10.8, Chrome 24 on Linux, and Chrome 24 on Mac OS 10.8.</p>

						<p>All other capabilities are not permuted, but are simply passed as-is to the WebDriver server.</p>

						<p>Different cloud testing services use different capability values when specifying environment capabilities. For example, Sauce Labs uses 'Windows XP' to specify the Windows XP platform while BrowserStack uses 'XP'. Check <a href="#options-capabilities">the list above</a> to find the right capabilities for your chosen platform.</p>

						<div class="a half" id="option-environmentRetries"></div>
						<h4>environmentRetries (number) <span class="versionBadge">3.0</span></h4>

						<p>The number of times to retry creating a session for a remote environment. Occasionally, hosted VM services will experience temporary failures when creating a new session; specifying <code>environmentRetries</code> avoids false positives caused by transient session creation failures.</p>

						<div class="a half" id="option-functionalSuites"></div>
						<h4>functionalSuites (Array&lt;string>)</h4>

						<p>An array of functional test module IDs to load. <a href="#writing-functional-test">Functional tests</a> are different from unit tests because they are executed on the local (Node.js) side, not the remote (browser) side, so they are specified separately from the list of unit test modules.</p>

						<pre><code class="javascript">{
	functionalSuites: [
		'tests/functional/foo',
		'tests/functional/bar'
	]
}</code></pre>

						<p>As with <code>suites</code>, functional suite specifiers may also include <a href="#option-suites">glob patterns</a>.</p>

						<div class="a half" id="option-leaveRemoteOpen"></div>
						<h4>leaveRemoteOpen (boolean | string) <span class="versionBadge">3.0</span></h4>
						<p>Leaves the remote environment running at the end of the test run. This makes it easier to investigate a browser’s state when debugging failing tests. This can also be set to <code>fail</code> to only keep the remote environment running when a test failure has occurred.</p>

						<p>In Intern 2, this option is available, but only as a command-line flag.</p>

						<div class="a half" id="option-maxConcurrency"></div>
						<h4>maxConcurrency (number)</h4>

						<p>The maximum number of environments to test simultaneously. Set this to <code class="javascript">Infinity</code> to run tests against all environments at once. You may want to reduce this if you have a limited number of test machines available, or are using a shared hosted account.</p>

						<div class="a half" id="option-proxyOnly"></div>
						<h4>proxyOnly (boolean) <span class="versionBadge">3.0</span></h4>

						<p>Starts Intern’s instrumenting HTTP proxy but performs no other work. <a href="#option-basePath"><code>basePath</code></a> will be served as the root of the server. This can be useful when you want to run the <a href="#browser-client">browser client</a> manually and get access to code coverage information, which is not available when running the browser client directly from a normal HTTP server. The browser client is available from <a href="#option-proxyUrl">{proxyUrl}</a>/__intern/client.html.</p>

						<p>In Intern 2, this option is available, but only as a command-line flag.</p>

						<div class="a half" id="option-proxyPort"></div>
						<h4>proxyPort (number)</h4>

						<p>The port where the Intern HTTP server will listen for requests. Intern’s HTTP server performs two critical tasks:</p>

						<ul>
							<li>Automatically adds instrumentation to your JavaScript code so that it can be analysed for completeness by the code coverage reporter</li>
							<li>Provides a communication conduit for the unit testing system to provide live test results in runner mode</li>
						</ul>

						<p>Any JavaScript code that you want to evaluate for code coverage must either pass through the code coverage proxy or be <!--<a href="TODO">-->pre-instrumented<!--</a>--> for Intern. The HTTP server must also be accessible to the environment (browser) being tested in runner mode in order for unit testing results to be transmitted back to the test runner successfully.</p>

						<div class="a half" id="option-proxyUrl"></div>
						<h4>proxyUrl (string)</h4>

						<p>The external URL to the Intern HTTP server. You will need to change this value only if you are running Intern’s HTTP server through a reverse proxy, or if Intern’s HTTP server needs to be reached through a public interface that your Selenium servers can access directly.</p>

						<div class="a half" id="option-runnerClientReporter"></div>
						<h4>runnerClientReporter (string | Object) <span class="versionBadge">3.0</span></h4>

						<p>The reporter used to send data from the unit testing system back to the test runner. The default reporter is the built-in WebDriver reporter, which can be configured by setting <code>runnerClientReporter</code> to an object with one or more properties:</p>

						<table class="api">
							<thead>
								<tr>
									<th>Option</th>
									<th>Type</th>
									<th>Default</th>
								</tr>
							</thead>
							<tr>
								<th scope="row">waitForRunner</th>
								<td>Whether or not events transmitted from the unit testing system to the test runner should cause the unit testing system to pause until a response is received from the test runner. This is necessary if you expect to be able to do things like take screenshots of the browser before/after each unit test executes from a custom reporter. This property can be set to <code class="javascript">true</code> to always wait for the test runner after each event from the test system, or <code class="javascript">'fail'</code> to only wait if the event was a test failure or other error.</td>
								<td><code class="javascript">false</code></td>
							</tr>
							<tr>
								<th scope="row">writeHtml</th>
								<td>Whether or not test status should be written to the screen during the test run. This is useful for debugging test hangs when running on a cloud provider, but can also interfere with tests that rely on scrolling/positioning or code which indiscriminately destroys the content of the DOM.</td>
								<td><code class="javascript">true</code></td>
							</tr>
						</table>

						<aside class="whatAreYouCrazy"><p>You can swap out the client reporter with a completely different reporter if you want by specifying its ID, but doing so will break the test runner if you don’t know what you are doing.</p></aside>

						<div class="a half" id="option-tunnel"></div>
						<h4>tunnel (string)</h4>

						<p>The tunnel to use to establish a WebDriver server for testing. The tunnel can either be a <a href="https://theintern.github.io/digdug/">built-in tunnel name</a> (like <code class="javascript">'NullTunnel'</code> or <code class="javascript">'BrowserStackTunnel'</code>), or an absolute AMD module ID (like <code class="javascript">'tests/support/CustomTunnel'</code>) when using a custom tunnel.</p>


						<p>The following tunnels are built in to Intern:</p>

						<ul>
							<li><a href="https://theintern.github.io/digdug/BrowserStackTunnel.html">BrowserStackTunnel</a> – For use with <a href="https://browserstack.com">BrowserStack</a></li>
							<li><a href="https://theintern.github.io/digdug/NullTunnel.html">NullTunnel</a> – For use with any other WebDriver server</li>
							<li><a href="https://theintern.github.io/digdug/SauceLabsTunnel.html">SauceLabsTunnel</a> – For use with <a href="https://saucelabs.com">Sauce Labs</a></li>
							<li><a href="https://theintern.github.io/digdug/TestingBotTunnel.html">TestingBotTunnel</a> – For use with <a href="https://testingbot.com">TestingBot</a></li>
						</ul>

						<p>When you are using <a href="#local-selenium">your own Selenium server</a> or <a href="#selenium-grid">your own Selenium grid</a>, you will typically use the <code class="javascript">'NullTunnel'</code> tunnel and specify the <code>host</code>, <code>port</code>, and/or <code>path</code> to the Selenium server in <a href="#option-tunnelOptions">tunnelOptions</a>.</p>

						<div class="a half" id="option-tunnelOptions"></div>
						<h4>tunnelOptions (Object)</h4>

						<p>Options to pass to the WebDriver server tunnel. Valid options for each of the built-in tunnels can be found in the <a href="https://theintern.github.io/digdug/">Dig Dug documentation</a>.</p>
					</article>

					<article>
						<div class="a" id="interfaces"></div>
						<h2 data-id="interfaces">Test interfaces</h2>

						<div class="a half" id="interface-overview"></div>
						<h3 data-id="interface-overview">Overview</h3>

						<p>Test interfaces are the way in which your tests make it into Intern. You can use one of the standard interfaces that come with Intern, or you can <a href="#custom-interfaces">create your own custom interface</a> if you don’t like the available defaults.</p>

						<aside class="tip"><p>If you already have a suite of tests written for a different testing framework, you don’t have to rewrite all of your tests! Just create a custom interface that provides the same API as your old test system.</p></aside>

						<aside class="whatAreYouCrazy"><p>Because test interfaces are independent from the rest of the testing system, you can use more than one test interface at the same time in a single project. Just be careful not to introduce unnecessary inconsistencies by doing this!</p></aside>

						<div class="a half" id="interface-object"></div>
						<h3 data-id="interface-object">The Object interface</h3>

						<p>The Object interface is the most basic API for writing tests. It exposes a single function, usually referenced as <code>registerSuite</code>. This function is used to register a series of tests by passing in a plain JavaScript object containing test functions:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');

	registerSuite({
		name: 'Suite name',

		setup: function () {
			// executes before suite starts;
			// can also be called `before` instead of `setup`
		},

		teardown: function () {
			// executes after suite ends;
			// can also be called `after` instead of `teardown`
		},

		beforeEach: function (test <span class="versionBadge">3.0</span>) {
			// executes before each test
		},

		afterEach: function (test <span class="versionBadge">3.0</span>) {
			// executes after each test
		},

		'Test foo': function () {
			// a test case
		},

		'Test bar': function () {
			// another test case
		},

		/* … */
	});
});</code></pre>

						<p>If you need to hold variables that are modified by test suites, it’s important to pass a function to <code>registerSuite</code> and create the variables inside that function, instead of putting the variables directly inside the factory:</p>

						<pre><code class="javascript">define(function (require) {
	var assert = require('intern/chai!assert');
	var registerSuite = require('intern!object');

	// Don't put this here! This variable is shared!
	var counter = 0;

	registerSuite({
		name: 'Anti-pattern',

		setup: function () {
			app = {
				id: counter++
			};
		},

		'Test the id': function () {
			// May or may not be true! The value of `counter`
			// may have been modified by another suite execution!
			assert.strictEqual(app.id, counter - 1);
		}
	});
});</code></pre>

						<pre><code class="javascript">define(function (require) {
	var assert = require('intern/chai!assert');
	var registerSuite = require('intern!object');

	registerSuite(function () {
		// Do put this here! This variable is unique for each environment!
		var counter = 0;

		return {
			name: 'Correct pattern',

			setup: function () {
				app = {
					id: counter++
				};
			},

			'Test the id': function () {
				// The value of `counter` will always be what is expected
				assert.strictEqual(app.id, counter - 1);
			}
		};
	});
});</code></pre>

						<aside class="whatAreYouCrazy"><p>Failure to follow this guidance will cause extremely unpredictable test execution, but <em>only</em> once you start running functional tests against multiple environments concurrently using the <a href="#test-runner">test runner</a>! This defect will be invisible when running tests against a single environment or when running with <a href="#option-maxConcurrency">maxConcurrency</a> set to 1.</p></aside>

						<p>It is also possible to nest suites by using an object as a value instead of a function:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');

	registerSuite({
		name: 'Suite name',

		'Test foo': function () {
			// a test case
		},

		// this is a sub-suite, not a test
		'Sub-suite name': {
			// it can also have its own suite lifecycle methods
			setup: function () { /* … */ },
			teardown: function () { /* … */ },
			beforeEach: function () { /* … */ },
			afterEach: function () { /* … */ },

			'Sub-suite test': function () {
				// a test case inside the sub-suite
			},

			'Sub-sub-suite name': {
				// and so on…
			}
		},

		/* … */
	});
});</code></pre>

						<div class="a half" id="interface-tdd"></div>
						<h3 data-id="interface-tdd">The TDD &amp; BDD interfaces</h3>

						<p>The TDD &amp; BDD interfaces are nearly identical to each other, differing only slightly in the names of the properties that they expose. Registering suites and tests using the TDD &amp; BDD interfaces is more procedural than the <a href="#interface-object">Object interface</a>:</p>

						<pre><code class="javascript">define(function (require) {
	var tdd = require('intern!tdd');

	tdd.suite('Suite name', function () {
		tdd.before(function () {
			// executes before suite starts
		});

		tdd.after(function () {
			// executes after suite ends
		});

		tdd.beforeEach(function () {
			// executes before each test
		});

		tdd.afterEach(function () {
			// executes after each test
		});

		tdd.test('Test foo', function () {
			// a test case
		});

		tdd.test('Test bar', function () {
			// another test case
		});

		// …
	});
</code></pre>

						<p>The BDD interface attempts to enforce a more literary, behaviour-describing convention for suites and tests by using different names for its registration functions:</p>

						<pre><code class="javascript">define(function (require) {
	var bdd = require('intern!bdd');

	bdd.describe('the thing being tested', function () {
		bdd.before(function () {
			// executes before suite starts
		});

		bdd.after(function () {
			// executes after suite ends
		});

		bdd.beforeEach(function () {
			// executes before each test
		});

		bdd.afterEach(function () {
			// executes after each test
		});

		bdd.it('should do foo', function () {
			// a test case
		});

		bdd.it('should do bar', function () {
			// another test case
		});

		// …
	});
});</code></pre>

						<aside class="tip"><p>Both interfaces work the same, so just pick which style you prefer and stick with it!</p></aside>

						<p>Just like the Object interface, the TDD &amp; BDD interfaces allow suites to be nested by calling <code>tdd.suite</code> or <code>bdd.describe</code> from within a parent suite:</p>

						<pre><code class="javascript">define(function (require) {
	var tdd = require('intern!tdd');

	tdd.suite('Suite name', function () {
		tdd.test('Test foo', function () {
			// a test case
		});

		tdd.suite('Sub-suite name', function () {
			// it can also have its own suite lifecycle methods
			tdd.before(function () { /* … */ });
			tdd.after(function () { /* … */ });
			tdd.beforeEach(function () { /* … */ });
			tdd.afterEach(function () { /* … */ });

			tdd.test('Sub-test name', function () {
				// a test case inside the sub-suite
			});

			tdd.suite('Sub-sub-suite', function () {
				// and so on…
			})
		});

		// …
	});
</code></pre>

						<aside class="whatAreYouCrazy"><p>Don’t try to call <code>tdd.suite</code> or <code>bdd.describe</code> from inside a test case; it’s not supported.</p></aside>

						<div class="a half" id="interface-qunit"></div>
						<h3 data-id="interface-qunit">The QUnit interface</h3>

						<p>The QUnit interface provides a test interface that is compatible with the QUnit 1 API. This interface allows you to easily take existing QUnit tests and run them with Intern, or apply your existing QUnit knowledge to writing tests with Intern.</p>

						<p>Converting existing QUnit tests to use Intern is as simple as wrapping your test files to expose Intern’s QUnit interface:</p>

						<pre><code class="javascript">define(function (require) {
	var QUnit = require('intern!qunit');

	QUnit.module('Suite name');
	QUnit.test('Test foo', function (assert) {
		assert.expects(1);
		assert.ok(true, 'Everything is OK');
	});

	// … other tests …
});</code></pre>

						<aside class="whatAreYouCrazy"><p>The QUnit interface has been successfully used by multiple jQuery projects to convert their tests to Intern, but there may be some edge cases where its behaviour differs. Please <a href="https://github.com/theintern/intern/issues/new?body=Description:%0A%0ASteps+to+reproduce:%0A%0A1.%20%E2%80%A6%0A2.%20%E2%80%A6%0A3.%20%E2%80%A6%0A%0AExpected%20result:%0AActual%20result:%0A%0AIntern%20version:%0A%0AAny%20additional%20information:">let us know</a> if you run into any in your own projects!</p></aside>
					</article>

					<article>
						<div class="a" id="unit-testing"></div>
						<h2 data-id="unit-testing">Unit testing</h2>

						<div class="a half" id="writing-unit-test"></div>
						<h3 data-id="writing-unit-test">Writing a unit test</h3>

						<p>As described in the <a href="#fundamentals-overview">fundamentals overview</a>, unit tests are the cornerstone of every test suite. Unit tests allow us to test applications by loading and interacting directly with application code.</p>

						<p>In order to write a unit test, you first need to pick an <a href="#interface-overview">interface</a> to use. For the sake of clarity, this guide uses the <a href="#interface-object">Object interface</a>, but all the test and suite lifecycle functions themselves are written the same way, and have the same functionality, no matter which interface you use.</p>

						<p>A unit test function, at its most basic level, is simply a function that throws an error when a test failure occurs, or throws no errors when a test passes:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');

	registerSuite({
		'passing test': function () {},
		'failing test': function () {
			throw new Error('Oops');
		}
	});
});</code></pre>

						<p>The <code class="javascript">this</code> keyword within a test function in Intern refers to the internal <a href="#test-object">Test object</a>. This object provides functionality for <a href="#async-tests">asynchronous testing</a> and <a href="#skipping-tests">skipping tests</a>.</p>

						<p>In order to facilitate testing, the <a href="http://chaijs.com/">Chai Assertion Library</a> is bundled with Intern. Chai allows us to easily verify that certain operations perform as expected by comparing expected and actual values and throwing useful errors when they don’t match:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');

	registerSuite({
		'passing test': function () {
			var result = 2 + 3;

			assert.equal(result, 5,
				'Addition operator should add numbers together');
		},
		'failing test': function () {
			var result = 2 * 3;

			assert.equal(result, 5,
				'Addition operator should add numbers together');
		}
	});
});</code></pre>

						<aside class="tip"><p>Good code comments describe <em>why</em> code is doing something and not <em>what</em> it is doing. Similarly, good assertion messages describe <em>why</em> the assertion exists and not <em>what</em> it is asserting. Keep this in mind as you write your tests!</p></aside>

						<p>Chai provides its own set of different interfaces for providing assertions. They all do the same things, so just like Intern’s test interfaces, pick the one whose syntax you prefer:</p>

						<ul>
							<li>The <a href="http://chaijs.com/guide/styles/#assert">assert</a> API, loaded from <code class="javascript">'intern/chai!assert'</code>, looks like <code class="javascript">assert.isTrue(value)</code></li>
							<li>The <a href="http://chaijs.com/guide/styles/#expect">expect</a> API, loaded from <code class="javascript">'intern/chai!expect'</code>, looks like <code class="javascript">expect(value).to.be.true</code></li>
							<li>The <a href="http://chaijs.com/guide/styles/#should">should</a> API, loaded from <code class="javascript">'intern/chai!should'</code>, looks like <code class="javascript">value.should.be.true</code></li>
						</ul>

						<aside class="tip"><p>When using the assert API, an easy way to remember the order of arguments is that they are alphabetical: <em>a</em>ctual, <em>e</em>xpected, <em>m</em>essage.</p></aside>

						<aside class="whatAreYouCrazy"><p>The should-style API pollutes the global <code>Object.prototype</code> and doesn’t work with null/undefined values or objects that don’t inherit from <code>Object.prototype</code>. It is recommended that this style of assertion be avoided.</p></aside>

						<div class="a half" id="test-lifecycle"></div>
						<h3 data-id="test-lifecycle">The test lifecycle</h3>

						<p>When tests are executed, the test system follows a specific lifecycle:</p>

						<!-- TODO: Diagram is better? -->
						<ul>
							<li>For <em>each registered root suite</em>:
								<ul>
									<li>The <a href="#suite-object-setup">setup</a> method of the suite is called, if it exists</li>
									<li>For <em>each test</em> within the suite:
										<ul>
											<li>The <a href="#suite-object-beforeEach">beforeEach</a> method of the suite is called, if it exists</li>
											<li>The test function is called</li>
											<li>The <a href="#suite-object-afterEach">afterEach</a> method of the suite is called, if it exists</li>
										</ul>
									</li>
									<li>The <a href="#suite-object-teardown">teardown</a> method of the suite is called, if it exists</li>
								</ul>
							</li>
						</ul>

						<p>So, given the this test module:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');

	registerSuite({
		setup: function () {
			console.log('outer setup');
		},
		beforeEach: function () {
			console.log('outer beforeEach');
		},
		afterEach: function () {
			console.log('outer afterEach');
		},
		teardown: function () {
			console.log('outer teardown');
		},

		'inner suite': {
			setup: function () {
				console.log('inner setup');
			},
			beforeEach: function () {
				console.log('inner beforeEach');
			},
			afterEach: function () {
				console.log('inner afterEach');
			},
			teardown: function () {
				console.log('inner teardown');
			},

			'test A': function () {
				console.log('inner test A');
			},
			'test B': function () {
				console.log('inner test B');
			}
		},

		'test C': function () {
			console.log('outer test C');
		}
	});
});</code></pre>

						<p>…the resulting console output would be in this order:</p>

						<pre><samp>outer setup
inner setup
outer beforeEach
inner beforeEach
inner test A
inner afterEach
outer afterEach
outer beforeEach
inner beforeEach
inner test B
inner afterEach
outer afterEach
inner teardown
outer beforeEach
outer test C
outer afterEach
outer teardown</samp></pre>

						<p>The <code class="javascript">this</code> keyword inside of the suite lifecycle methods (setup, beforeEach, afterEach, teardown) refers to the internal <a href="#suite-object">Suite object</a>.</p>

						<div class="a half" id="async-tests"></div>
						<h3 data-id="async-tests">Asynchronous tests</h3>

						<p>As mentioned in the earlier section on <a href="#conventions">conventions</a>, asynchronous testing in Intern is based on Promises. When writing a test, you may either return a Promise from your test function (convenient for interfaces that already use Promises), or call <code>this.async</code> from within a test function to create a promise for that test.</p>

						<h4>Returning a Promise</h4>

						<p>If your test returns a promise (any object with a then function), it is understood that your test is asynchronous. Resolving the promise indicates a passing test, and rejecting the promise indicates a failed test. The test will also fail if the promise is not fulfilled within the timeout of the test (the default is 30 seconds; set <code>this.timeout</code> to change the value).</p>

						<h4>Calling this.async</h4>

						<p>All tests have a <code>this.async</code> method that can be used to retrieve a Deferred object. It has the following signature:</p>

						<pre><code class="typescript">this.async(timeout?: number, numCallsUntilResolution?: number): Deferred;</code></pre>

						<p>After calling this method, Intern will assume your test is asynchronous, even if you do not return a Promise. (If you do return a Promise, the returned Promise takes precedence over the one generated by <code>this.async</code>.)</p>

						<p>The Deferred object by <code>this.async</code> includes a reference to the generated Promise, along with methods for resolving and rejecting the promise:</p>

						<table class="api">
							<tr>
								<th>Property/method</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">callback(fn: Function): Function</th>
								<td>Returns a function that, when called, resolves the Promise if <code>fn</code> does not throw an error, or rejects the Promise if it does. This is the most common way to complete an asynchronous test.</td>
							</tr>
							<tr>
								<th scope="row">promise: Promise</th>
								<td>The underlying Promise object for this Deferred.</td>
							</tr>
							<tr>
								<th scope="row">reject(error: Error): void</th>
								<td>Rejects the Promise. The error passed to <code>reject</code> is used as the error for reporting the test failure.</td>
							</tr>
							<tr>
								<th scope="row">rejectOnError(fn: Function): Function</th>
								<td>Returns a function that, when called, does nothing if <code>fn</code> does not throw an error, or rejects the Promise if it does. This is useful when working with nested callbacks where only the innermost callback should resolve the Promise but a failure in any of the outer callbacks should reject it.</td>
							</tr>
							<tr>
								<th scope="row">resolve(value?: any): void</th>
								<td>Resolves the Promise. The resolved value is not used by Intern.</td>
							</tr>
						</table>

						<p>The <code>this.async</code> method accepts two optional arguments:</p>

						<table class="api">
							<tr>
								<th>Argument</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">timeout</th>
								<td>Set the timeout of the test in milliseconds. Equivalent to setting <code>this.timeout</code>. If not provided, this defaults to 30 seconds.</td>
							</tr>
							<tr>
								<th scope="row">numCallsUntilResolution</th>
								<td>Specifies how many times the <code>callback</code> method should be called before actually resolving the Promise. This defaults to 1. <code>numCallsUntilResolution</code> is only useful in rare cases where you may have a callback that will be called several times and the test should be considered complete only on the last invocation.</td>
							</tr>
						</table>

						<p>A basic asynchronous test using <code>this.async</code> looks like this:

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');

	var request = require('request');

	registerSuite({
		name: 'async demo',

		'async test': function () {
			var dfd = this.async(1000);

			request(
				'http://example.com/test.txt',
				dfd.callback(function (error, data) {
					if (error) {
						throw error;
					}

					assert.strictEqual(data, 'Hello world!');
				})
			);
		}
	});
});</code></pre>

						<p>In this example, an HTTP request is made using a hypothetical <code>request</code> library that uses legacy Node.js-style callbacks. When the call is completed successfully, the data is checked to make sure it is correct.</p>

						<p>If the data is correct, the Promise associated with <code>dfd</code> will be resolved, and the test will pass; otherwise, it will be rejected (because an error is thrown), and the test will fail.</p>

						<div class="a half" id="skipping-tests"></div>
						<h3 data-id="skipping-tests">Skipping tests at runtime</h3>

						<p>All tests have a <code>skip</code> method that can be used to skip the test if it should not be executed for some reason:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');

	registerSuite({
		name: 'skip demo',

		'skip test': function () {
			if (typeof window === 'undefined') {
				this.skip('Browser-only test');
			}

			// ...
		}
	});
});</code></pre>

						<aside class="tip"><p>Calling <code>this.skip</code> halts execution of the rest of the function, so it is not necessary to <code>return</code> after calling it.</p></aside>

						<p>The <a href="#option-grep">grep configuration option</a> can also be used to skip tests whose IDs don’t match a regular expression.</p>

						<p>Suites also have a <code>skip</code> method. Calling <code>this.skip()</code> from a suite lifecycle method, or calling <code>this.parent.skip()</code> from a test, will cause all remaining tests in a suite to be skipped.</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');

	registerSuite({
		name: 'skip demo',

		setup: function () {
			// Skip entire suite if not running in a browser
			if (typeof window === 'undefined') {
				this.skip('Browser-only suite');
			}
		},

		'test 1': function () {
			// test code
		},

		'test 2': function () {
			// Skip remainder of suite if `someVar` isn't defined
			if (window.someVar == null) {
				this.parent.skip('somVar not defined');
			}
			// test code
		},

		// tests ...
	});
});</code></pre>

						<aside class="tip"><p>When a test is skipped because <code>this.skip()</code> or <code>this.parent.skip()</code> was called from within the test, the <code>beforeEach</code> and <code>afterEach</code> lifecycle methods are still executed for that test. However, when tests are skipped due to <code>grep</code> or because <code>skip</code> was called on a suite (either in a lifecycle method or in a previous test), <code>beforeEach</code> and <code>afterEach</code> are <em>not</em> executed for the skipped test(s).</p></aside>

						<div class="a half" id="testing-commonjs-code"></div>
						<h3 data-id="testing-commonjs-code">Testing CommonJS modules</h3>

						<p>CommonJS modules, including Node.js built-ins, can be loaded as dependencies to a test module using the <code>dojo/node</code> loader plugin that comes with Intern:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');
	var path = require('intern/dojo/node!path');

	registerSuite({
		name: 'path',

		'basic tests': function () {
			var ab = path.join('a', 'b');

			// …
		}
	});
});</code></pre>

						<aside class="tip"><p>CommonJS modules will be loaded using the native Node.js loader. This means they will follow the Node.js module path resolution rules. It also means that AMD loader features like <code>map</code> cannot be used when testing CommonJS modules to mock their dependencies.</p></aside>

						<div class="a half" id="testing-global-code"></div>
						<h3 data-id="testing-global-code">Testing non-modular code</h3>

						<p>Browser code that doesn’t support any module system and expects to be loaded along with other dependencies in a specific order can be loaded using the <code>intern/order</code> loader plugin:</p>

						<pre><code class="javascript">define([
	'intern!object',
	'intern/chai!assert',
	'intern/order!../jquery.js',
	'intern/order!../plugin.jquery.js'
], function (registerSuite, assert) {
	registerSuite({
		name: 'plugin.jquery.js',

		'basic tests': function () {
			jQuery('&lt;div>').plugin();
			// …
		}
	});
});</code></pre>

						<p>It is also possible to use the <a href="https://github.com/tbranyen/use-amd">use-amd</a> loader plugin to load non-modular code:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');
	var jQuery = require('use!plugin.jquery');

	registerSuite({
		name: 'plugin.jquery.js',

		'basic tests': function () {
			jQuery('&lt;div>').plugin();
			// …
		}
	});
});</code></pre>

						<p>In this case, the dependency ordering is handled by use-amd instead.</p>

						<aside class="whatAreYouCrazy"><p>Authoring non-modular code that pollutes the global scope is strongly discouraged. Any code using this style should be upgraded… just as soon as you have a good test suite you can use to prevent regressions!</p></aside>

						<div class="a half" id="testing-other-module"></div>
						<h3 data-id="testing-other-module">Testing other transpiled code</h3>

						<p>Other transpiled code can be tested without requiring a build step by first writing a <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">loader plugin</a> that performs code compilation for you:</p>

						<pre><code class="javascript">// in tests/support/customscript.js
define(function (require) {
	var compiler = require('customscript');
	var request = require('intern/dojo/request');

	return {
		load: function (resourceId, require, load) {
			// Get the raw source code…
			request(require.toUrl(resourceId)).then(function (sourceCode) {
				// …then compile it into JavaScript code…
				compiler.compile(sourceCode).then(function (javascriptCode) {
					// …then execute the compiled function. In this case,
					// the compiled code returns its value. An AMD module would
					// call a `define` function, and a CJS module would set its
					// values on `exports` or `module.exports`.
					load(new Function(javascriptCode)());
				});
			});
		}
	};
});</code></pre>

						<p>Once you have a suitable loader plugin, just load your code through the loader plugin like any other dependency:</p>

						<pre><code class="javascript">// in tests/unit/foo.js
define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');
	var foo = require('../support/customscript!app/foo.cs');

	registerSuite({
		name: 'app/foo',

		'basic tests': function () {
			foo.doSomething();
			// …
		}
	});
});</code></pre>

						<aside class="tip"><p>This same mechanism can be used to write the test modules themselves in a different language or module format by referencing a loader plugin ID in the <a href="#option-suites">suites</a> and <a href="#option-functionalSuites">functionalSuites</a> arrays.</p></aside>

						<div class="a half" id="testing-cors"></div>
						<h3 data-id="testing-cors">Testing non-CORS APIs</h3>

						<p>When writing unit tests with Intern, occasionally you will need to interact with a Web service using XMLHttpRequest. However, because the <a href="#test-runner">test runner</a> serves code at http://localhost:9000 by default, any cross-origin requests will fail.</p>

						<p>In order to test Ajax requests without using CORS or JSONP, the solution is to set up a reverse proxy to Intern and tell the test runner to load from that URL instead by setting the <a href="#option-proxyUrl">proxyUrl</a> configuration option.</p>

						<p>You can either set up the Web server to only send requests to Intern for your JavaScript files, or you can set up the Web server to send all requests to Intern except for the Web services you’re trying to access.</p>

						<h4>Option 1: All traffic except Web services to Intern</h4>

						<ol>
							<li>Modify <a href="#option-proxyUrl">proxyUrl</a> in your Intern configuration to point to the URL where the Web server lives</li>
							<li>Set up the Web server to reverse proxy to http://localhost:9000/ by default</li>
							<li>Add <code>location</code> directives to pass the more specific Web service URLs to the Web service instead</li>
						</ol>

						<p>An nginx configuration implementing this pattern might look like this:</p>

						<pre><code class="nginx">server {
	server_name proxy.example;

	location /web-service/ {
		# This will proxy to http://www.web-service.example/web-service/&lt;rest of url>;
		# use `proxy_pass http://www.web-service.example/` to proxy to
		# http://www.web-service.example/&lt;rest of url> instead
		proxy_pass http://www.web-service.example;
	}

	location / {
		proxy_pass http://localhost:9000;
	}
}</code></pre>

					<h4>Option 2: Only JavaScript traffic to Intern</h4>

					<ol>
						<li>Modify <a href="#option-proxyUrl">proxyUrl</a> in your Intern configuration to point to the URL where the Web server lives</li>
						<li>Set up the Web server to reverse proxy to http://localhost:9000/ for the special /__intern/ location, plus any directories that contain JavaScript</li>
					</ol>

					<p>An nginx configuration implementing this pattern might look like this:</p>

					<pre><code class="nginx">server {
	server_name proxy.example;
	root /var/www/;

	location /js/ {
		proxy_pass http://localhost:9000;
	}

	location /__intern/ {
		proxy_pass http://localhost:9000;
	}

	location / {
		try_files $uri $uri/ =404;
	}
}</code></pre>
					</article>

					<article>
						<div class="a" id="functional-testing"></div>
						<h2 data-id="functional-testing">Functional testing</h2>

						<div class="a half" id="writing-functional-test"></div>
						<h3 data-id="writing-functional-test">Writing a functional test</h3>

						<p>As described in the <a href="#fundamentals-overview">fundamentals overview</a>, functional testing enables application testing by automating user interactions like navigating to pages, scrolling, clicking, reading content, etc.. It’s used as an automated alternative to manual user testing.</p>

						<p>Functional tests are registered using the same interfaces as <a href="#writing-unit-tests">unit tests</a>, and use the same internal <a href="#suite-object">Suite</a> and <a href="#test-object">Test</a> objects, but are loaded using the <a href="#option-functionalSuites">functionalSuites</a> configuration option instead of the <a href="#option-suites">suites</a> option and run inside the test runner instead of inside the environment being tested.</p>

						<p>When writing a functional test, instead of executing application code directly, use the <a href="https://theintern.github.io/leadfoot/Command.html">Leadfoot Command object</a> at <code>this.remote</code> to automate interactions that you’d normally perform manually to test an application:</p>

						<pre><code class="javascript">define(function (require) {
	var registerSuite = require('intern!object');
	var assert = require('intern/chai!assert');

	registerSuite({
		name: 'index',

		'greeting form': function () {
			return this.remote
				.<a href="https://theintern.github.io/leadfoot/Command.html#get">get</a>(require.toUrl('index.html'))
				.<a href="https://theintern.github.io/leadfoot/Command.html#setFindTimeout">setFindTimeout</a>(5000)
				.<a href="https://theintern.github.io/leadfoot/Command.html#findByCssSelector">findByCssSelector</a>('body.loaded')
				.<a href="https://theintern.github.io/leadfoot/Command.html#findById">findById</a>('nameField')
					.<a href="https://theintern.github.io/leadfoot/Command.html#click">click</a>()
					.<a href="https://theintern.github.io/leadfoot/Command.html#type">type</a>('Elaine')
					.<a href="https://theintern.github.io/leadfoot/Command.html#end">end</a>()
				.<a href="https://theintern.github.io/leadfoot/Command.html#findByCssSelector">findByCssSelector</a>('#loginForm input[type=submit]')
					.<a href="https://theintern.github.io/leadfoot/Command.html#click">click</a>()
					.<a href="https://theintern.github.io/leadfoot/Command.html#end">end</a>()
				.<a href="https://theintern.github.io/leadfoot/Command.html#findById">findById</a>('greeting')
					.<a href="https://theintern.github.io/leadfoot/Command.html#getVisibleText">getVisibleText</a>()
					.<a href="https://theintern.github.io/leadfoot/Command.html#then">then</a>(function (text) {
						assert.strictEqual(text, 'Hello, Elaine!',
							'Greeting should be displayed when the form is submitted');
					});
		}
	});
});</code></pre>

						<aside class="whatAreYouCrazy"><p>Always make sure that you either <code class="javascript">return</code> the final call to the remote object, or return another Promise that resolves after all of your commands have finished executing. If you don’t, Intern won’t wait before moving on to the next test, and your test suite will be broken.</p></aside>

						<p>In this example, taken from the <a href="https://github.com/theintern/intern-tutorial">Intern tutorial</a>, we’re automating interaction with a basic form that is supposed to accept a name from the user and then display it as a greeting in the user interface. As can be seen from the code above, the series of steps the test takes are as follows:</p>

						<ul>
							<li>Load the page. <code>require.toUrl</code> is used here to convert a local file path (index.html) into a URL that can actually be loaded by the remote browser (<a href="#option-proxyUrl">http://localhost:9000</a>/index.html).</li>
							<li>Set a timeout of 5 seconds for each attempt to find an element on the page. This ensures that even if the browser takes a couple of seconds to create an element, the test won’t fail</li>
							<li>Wait for the page to indicate it has loaded by putting a <code>loaded</code> class on the body element</li>
							<li>Find the form field where the name should be typed</li>
							<li>Click the field and type a name into it</li>
							<li>Find the submit button for the form. Note that if <code>end</code> hadn’t been called on the previous line, Intern would try to find the <code>#loginForm input[type=submit]</code> element from inside the previously selected <code>nameField</code> element, instead of inside the body of the page</li>
							<li>Click the submit button</li>
							<li>Find the element where the greeting is supposed to show</li>
							<li>Get the text from the greeting</li>
							<li>Verify that the correct greeting is displayed</li>
						</ul>

						<aside class="whatAreYouCrazy"><p>Calling <code>this.remote.quit()</code> will break Intern, so don’t do it. Intern will always handle cleaning up the remote environment on your behalf once testing is finished.</p></aside>

						<div class="a half" id="page-objects"></div>
						<h3 data-id="page-objects">Page objects</h3>

						<p>A <dfn>page object</dfn> is like a widget for your test code. It abstracts away the details of your UI so you can avoid tightly coupling your test code to a specific view (DOM) tree design.</p>

						<p>Using page objects means that if the view tree for part of your UI is modified, you only need to make a change in the page object to fix all your tests. Without page objects, every time the views in your application change, you’d need to touch every single test that interacts with that part of the UI.</p>

						<p>Once you’ve written a page object, your tests will use the page object to interact with a page instead of the low-level methods of the <code>this.remote</code> object.</p>

						<p>For example, a page object for the index page of a Web site could be written like this:</p>

						<pre><code class="javascript">// in tests/support/pages/IndexPage.js
define(function (require) {
  // the page object is created as a constructor
  // so we can provide the remote Command object
  // at runtime
	function IndexPage(remote) {
		this.remote = remote;
	}

	IndexPage.prototype = {
		constructor: IndexPage,

		// the login function accepts username and password
		// and returns a promise that resolves to `true` on
		// success or rejects with an error on failure
		login: function (username, password) {
			return this.remote
				// first, we perform the login action, using the
				// specified username and password
				.findById('login')
				.click()
				.type(username)
				.end()
				.findById('password')
				.click()
				.type(password)
				.end()
				.findById('loginButton')
				.click()
				.end()
				// then, we verify the success of the action by
				// looking for a login success marker on the page
				.setFindTimeout(5000)
				.findById('loginSuccess')
				.then(function () {
					// if it succeeds, resolve to `true`; otherwise
					// allow the error from whichever previous
					// operation failed to reject the final promise
					return true;
				});
		},

		// …additional page interaction tasks…
	};

	return IndexPage;
});</code></pre>

						<p>Then, the page object would be used in tests instead of the <code>this.remote</code> object:</p>

						<pre><code class="javascript">// in tests/functional/index.js
define([
	'intern!object',
	'intern/chai!assert',
	'../support/pages/IndexPage'
], function (registerSuite, assert, IndexPage) {
	registerSuite(function () {
		var indexPage;
		return {
			// on setup, we create an IndexPage instance
			// that we will use for all the tests
			setup: function () {
				indexPage = new IndexPage(this.remote);
			},

			'successful login': function () {
				// then from the tests themselves we simply call
				// methods on the page object and then verify
				// that the expected result is returned
				return indexPage
					.login('test', 'test')
					.then(function (loggedIn) {
						assert.isTrue(loggedIn,
							'Valid username and password should log in successfully');
					});
			},

			// …additional tests…
		};
	});
});</code></pre>

						<div class="a half" id="native-apps"></div>
						<h3 data-id="native-apps">Testing native apps</h3>

						<p>Native mobile application UIs can be tested by Intern using an <a href="http://appium.io/">Appium</a>, <a href="http://ios-driver.github.io/ios-driver/">ios-driver</a>, or <a href="http://selendroid.io/">Selendroid</a> server. Each server has slightly different support for WebDriver, so make sure to read each project’s documentation to pick the right one for you.</p>

						<aside class="whatAreYouCrazy"><p>Always be sure to set <code>fixSessionCapabilities: false</code> in your environment capabilities when testing a native app to bypass feature detection code that only works for Web apps.</p></aside>

						<h4>Appium</h4>

						<p>To test a native app with Appium, one method is to pass the path to a valid IPA or APK using the <code>app</code> key in your <a href="#option-environments">environments</a> configuration:</p>

						<pre><code class="javascript">{
	environments: [
		{
			platformName: 'iOS',
			app: 'testapp.ipa',
			fixSessionCapabilities: false
		}
	]
}</code></pre>

						<p>You can also use <code>appPackage</code> and <code>appActivity</code> for Android, or <code>bundleId</code> and <code>udid</code> for iOS, to run an application that is already installed on a test device:</p>

						<pre><code class="javascript">{
	environments: [
		{
			platformName: 'iOS',
			bundleId: 'com.example.TestApp',
			udid: 'da39a3ee5e…',
			fixSessionCapabilities: false
		},
		{
			platformName: 'Android',
			appActivity: 'MainActivity',
			appPackage: 'com.example.TestApp',
			fixSessionCapabilities: false
		}
	]
}</code></pre>

						<aside class="tip"><p>The available capabilities for Appium are complex, so review the <a href="http://appium.io/slate/en/master/#caps.md">Appium capabilities documentation</a> to understand all possible execution modes.</p></aside>

						<p>Once the application has started successfully, you can interact with it using any of the <a href="http://appium.io/slate/en/master/?javascript#finding-and-interacting-with-elements">supported WebDriver APIs</a>.</p>

						<h4>ios-driver</h4>

						<p>To test a native app with ios-driver, first run ios-driver, passing one or more app bundles for the applications you want to test:</p>

						<pre><kbd class="bash">java -jar ios-driver.jar -aut TestApp.app</kbd></pre>

						<p>Then, pass the bundle ID and version using the <code>CFBundleName</code> and <code>CFBundleVersion</code> keys in your <a href="#option-environments">environments</a> configuration:</p>

						<pre><code class="javascript">{
	environments: [
		{
			device: 'iphone',
			CFBundleName: 'TestApp',
			CFBundleVersion: '1.0.0',
			// required for ios-driver to use iOS Simulator
			simulator: true,
			fixSessionCapabilities: false
		}
	]
}</code></pre>

						<p>Once the application has started successfully, you can interact with it using any of the <a href="https://ios-driver.github.io/ios-driver/?page=native">supported WebDriver APIs</a>.</p>

						<h4>Selendroid</h4>

						<p>To test a native app with Selendroid, first run Selendroid, passing one or more APKs for the applications you want to test:</p>

						<pre><kbd class="bash">java -jar selendroid.jar -app testapp-1.0.0.apk</kbd></pre>

						<p>Then, pass the Android app ID of the application using the <code>aut</code> key in your <a href="#option-environments">environments</a> configuration:</p>

						<pre><code class="javascript">{
	environments: [
		{
			automationName: 'selendroid',
			aut: 'com.example.testapp:1.0.0',
			fixSessionCapabilities: false
		}
	]
}</code></pre>

						<p>Once the application has started successfully, you can interact with it using any of the <a href="http://selendroid.io/native.html">supported WebDriver APIs</a>.</p>

						<div class="a half" id="debugging"></div>
						<h3 data-id="debugging">Debugging</h3>

						<p>Keep in mind that JavaScript code is running in two separate environments: your test suites are run in Node.js, while the page loaded by functional tests runs in a web browser. Debugging code on the test page should be done prior to testing time by opening it directly and using the browser's debugging tools. Debugging can be done with <a href="https://github.com/node-inspector/node-inspector">node-inspector</a>.</p>

						<ol>
							<li><kbd class="bash">npm install -g node-inspector</kbd></li>
							<li>Your test modules are loaded dynamically by Intern, so they will likely not show up in the debugger's file list. In order to set a break point you will need to add a debugger statement in your test code.</li>
							<li>Launch Node.js with debugging enabled, set to pause on the first line of code:
								<ul>
									<li><kbd class="bash">node --debug-brk node_modules/intern/runner config=myPackage/test/intern</kbd></li>
								</ul>
							</li>
							<li>Launch node-inspector by running <kbd class="bash">node-inspector</kbd>.</li>
							<li>Open Chrome (you must use Chrome as node-inspector leverages Chrome's developer tools) to:
								<ul>
									<li><kbd class="bash">http://127.0.0.1:8080/debug?port=5858</kbd></li>
								</ul>
							</li>
							<li>Continue code execution (F8) until your debugger statement.</li>
						</ol>
					</article>

					<article>
						<div class="a" id="webdriver-server"></div>
						<h2 data-id="webdriver-server">Getting a WebDriver server</h2>

						<div class="a half" id="hosted-selenium"></div>
						<h3 data-id="hosted-selenium">Cloud hosting</h3>

						<p>Using cloud hosting is the fastest way to get an operational Selenium server. Intern natively provides support for all three major cloud hosting providers:</p>

						<ul>
							<li><a href="https://browserstack.com/">BrowserStack</a></li>
							<li><a href="https://saucelabs.com/">Sauce Labs</a></li>
							<li><a href="https://testingbot.com/">TestingBot</a></li>
						</ul>

						<h4>BrowserStack</h4>

						<ol>
							<li><a href="https://www.browserstack.com/users/sign_up">Sign up</a> for <a href="https://www.browserstack.com/automate">BrowserStack Automate</a></li>
							<li>Get your Automate username and password from the <a href="https://www.browserstack.com/accounts/automate">Automate account settings page</a></li>
							<li>Set <a href="#option-tunnel">tunnel</a> to <code class="javascript">'BrowserStackTunnel'</code></li>
							<li
								>Set your username and access key in one of these ways:
								<ul>
									<li>Define <kbd>BROWSERSTACK_USERNAME</kbd> and <kbd>BROWSERSTACK_ACCESS_KEY</kbd> environment variables</li>
									<li>Set <code>browserstackUsername</code> and <code>browserstackAccessKey</code> in your Gruntfile’s intern task options</li>
									<li>Set <code>username</code> and <code>accessKey</code> on your <a href="#option-tunnelOptions">tunnelOptions</a> configuration option</li>
								</ul>
							</li>
						</ol>

						<h4>Sauce Labs</h4>

						<ol>
							<li><a href="https://saucelabs.com/signup/trial">Sign up</a> for a Sauce Labs account</li>
							<li>Get your master account access key from the sidebar of the <a href="https://saucelabs.com/account">Account settings page</a>, or create a separate sub-account on the <a href="https://saucelabs.com/sub-accounts">sub-accounts page</a> and get a username and access key from there</li>
							<li>Set <a href="#option-tunnel">tunnel</a> to <code class="javascript">'SauceLabsTunnel'</code></li>
							<li
								>Set your username and access key in one of these ways:
								<ul>
									<li>Define <kbd>SAUCE_USERNAME</kbd> and <kbd>SAUCE_ACCESS_KEY</kbd> environment variables</li>
									<li>Set <code>sauceUsername</code> and <code>sauceAccessKey</code> in your Gruntfile’s intern task options</li>
									<li>Set <code>username</code> and <code>accessKey</code> on your <a href="#option-tunnelOptions">tunnelOptions</a> configuration option</li>
								</ul>
							</li>
						</ol>

						<h4>TestingBot</h4>

						<ol>
							<li><a href="https://testingbot.com/users/sign_up">Sign up</a> for a TestingBot account</li>
							<li>Get your API key and secret from the <a href="https://testingbot.com/members/user/edit">Account settings page</a></li>
							<li>Set <a href="#option-tunnel">tunnel</a> to <code class="javascript">'TestingBotTunnel'</code></li>
							<li
								>Set your API key and secret in one of these ways:
								<ul>
									<li>Define <kbd>TESTINGBOT_KEY</kbd> and <kbd>TESTINGBOT_SECRET</kbd> environment variables</li>
									<li>Set <code>testingbotKey</code> and <code>testingbotSecret</code> in your Gruntfile’s intern task options</li>
									<li>Set <code>apiKey</code> and <code>apiSecret</code> on your <a href="#option-tunnelOptions">tunnelOptions</a> configuration option</li>
								</ul>
							</li>
						</ol>

						<aside class="tip"><p>Cloud hosts typically have their own unique capabilities options, so be sure to read the <a href="#option-capabilities">capabilities documentation</a> for the provider you’re using.</p></aside>

						<div class="a half" id="local-selenium"></div>
						<h3 data-id="local-selenium">Local Selenium</h3>

						<p>Depending upon which browsers you want to test locally, a few options are available.</p>

						<h4>Using ChromeDriver (Chrome-only)</h4>

						<p>If you’re just looking to have a local environment for developing functional tests, a stand-alone ChromeDriver installation works great.</p>

						<ol>
							<li><a href="http://chromedriver.storage.googleapis.com/index.html" title="ChromeDriver downloads">Download</a> the latest version of <a href="https://sites.google.com/a/chromium.org/chromedriver/">ChromeDriver</a></li>
							<li>Set <a href="#option-tunnel">tunnel</a> to <code class="javascript">'NullTunnel'</code></li>
							<li>Run <kbd class="bash">chromedriver --port=4444 --url-base=wd/hub</kbd></li>
							<li>Set your <a href="#option-environments">environments</a> capabilities to <code class="javascript">[ { browserName: 'chrome' } ]</code></li>
							<li>Run <a href="#test-runner">the test runner</a></li>
						</ol>

						<aside class="tip"><p>If you are having trouble starting the server or getting Intern to communicate with it, verify the server is running correctly by going to <a href="http://localhost:4444/wd/hub/status">http://localhost:4444/wd/hub/status</a>. It should return a JSON response with a <code>status</code> field of 0.</p></aside>

						<h4>Using PhantomJS 2</h4>

						<p>If you want to use a fake browser to develop your tests, PhantomJS 2 is an option.</p>

						<ol>
							<li><a href="http://phantomjs.org/download.html">Download</a> the latest version of <a href="http://phantomjs.org">PhantomJS</a></li>
							<li>Set <a href="#option-tunnel">tunnel</a> to <code class="javascript">'NullTunnel'</code></li>
							<li>Run <kbd class="bash">phantomjs --webdriver=4444</kbd></li>
							<li>Set your <a href="#option-environments">environments</a> capabilities to <code class="javascript">[ { browserName: 'phantomjs' } ]</code></li>
							<li>Run <a href="#test-runner">the test runner</a></li>
						</ol>

						<aside class="whatAreYouCrazy"><p>Since PhantomJS is not a real browser that your users will ever actually use, it’s not the best idea to rely on it for testing unless you have a <a href="#ci">continuous integration</a> system set up to test with real browsers.</p></aside>

						<h4>Using Selenium (all browsers)</h4>

						<p>If you want to test against more than just Chrome, start by downloading the servers for each platform you want to test:</p>

						<ul>
							<li>All platforms: <a href="http://selenium-release.storage.googleapis.com/index.html">Selenium server standalone</a> (selenium-server-standalone-{version}.jar)</li>
							<li>Firefox &amp; Safari: (bundled with Selenium server)</li>
							<li>Chrome &amp; Chrome for Android: <a href="http://chromedriver.storage.googleapis.com/index.html">ChromeDriver</a></li>
							<li>Internet Explorer: <a href="http://selenium-release.storage.googleapis.com/index.html">IEDriver server</a></li>
							<li>Android Browser: <a href="https://github.com/selendroid/selendroid/releases/">Selendroid server with dependencies</a></li>
							<li>Mobile Safari: <a href="http://ios-driver-ci.ebaystratus.com/userContent/">ios-driver server standalone</a></li>
						</ul>

						<aside class="whatAreYouCrazy"><p>New versions of Firefox will occasionally break Selenium. If this is the case, downgrade to an earlier version of Firefox until a new Selenium release is available. Once <a href="https://developer.mozilla.org/en-US/docs/Mozilla/QA/Marionette">Marionette</a> is updated to use the WebDriver wire protocol, this should no longer be an issue.</p></aside>

						<p>To start the server, run <kbd class="bash">java -jar selenium-server-standalone-{version}.jar</kbd>.</p>

						<p>To use ChromeDriver and IEDriver with a Selenium server, the driver executables must either be placed somewhere in the environment PATH, or their locations must be given explicitly to the Selenium server using the <kbd>-Dwebdriver.chrome.driver</kbd> (ChromeDriver) and <kbd>-Dwebdriver.ie.driver</kbd> (IEDriver) flags upon starting the Selenium server:</p>

						<pre><kbd class="bash">java -jar selenium-server-standalone-{version}.jar \
-Dwebdriver.chrome.driver=/path/to/chromedriver \
-Dwebdriver.ie.driver=C:/path/to/IEDriverServer.exe</kbd></pre>

						<p>Once the server is running, simply configure Intern to point to the server by setting <a href="#option-tunnel">tunnel</a> to <code class="javascript">'NullTunnel'</code>, then run the <a href="#test-runner">test runner</a>.</p>

						<aside class="tip"><p>If you are having trouble starting the server or getting Intern to communicate with it, verify the server is running correctly by going to <a href="http://localhost:4444/wd/hub/status">http://localhost:4444/wd/hub/status</a>. It should return a JSON response with a <code>status</code> field of 0.</p></aside>

						<p>Each driver you use with Selenium has its own installation and configuration requirements, so be sure to read the installation instructions for each:</p>

						<ul>
							<li><a href="https://code.google.com/p/selenium/wiki/FirefoxDriver">FirefoxDriver</a></li>
							<li><a href="https://code.google.com/p/selenium/wiki/SafariDriver">SafariDriver</a></li>
							<li><a href="https://sites.google.com/a/chromium.org/chromedriver/home">ChromeDriver</a></li>
							<li><a href="http://code.google.com/p/selenium/wiki/InternetExplorerDriver">IEDriver</a></li>
							<li><a href="http://selendroid.io">Selendroid</a></li>
							<li><a href="http://ios-driver.github.io/ios-driver/">ios-driver</a></li>
						</ul>

						<aside class="tip"><p>It is not necessary to manually add browser sessions to the server through the Web interface. Selenium will automatically create new sessions when a connection from Intern is established.</p></aside>

						<div class="a half" id="selenium-grid"></div>
						<h3 data-id="selenium-grid">Selenium Grid</h3>

						<p>selenium-server-standalone-{version}.jar includes both stand-alone and grid server functionality. To start a Selenium Grid, first create a hub by running Selenium server in hub mode:</p>

						<pre><kbd class="bash">java -jar selenium-server-standalone-{version}.jar -hub</kbd></pre>

						<p>The hub normally drives no browsers by its own and simply acts as a forwarding proxy to each of the nodes that have been registered with the hub.</p>

						<p>Once you’ve installed and configured all the drivers for one of your grid nodes following the instructions for setting up <a href="#local-selenium">local Selenium</a>, start the node and register it with the hub:</p>

						<pre><kbd class="bash">java -jar selenium-server-standalone-2.xx.x.jar -hub http://hub-server:4444/grid/register</kbd></pre>

						<p>Once the server is running, simply configure Intern to point to the hub by setting <a href="#option-tunnel">tunnel</a> to <code class="javascript">'NullTunnel'</code>, then run the <a href="#test-runner">test runner</a>.</p>

						<p>Creating a grid that works with Selendroid and ios-driver requires that additional <a href="http://search.maven.org/#browse%7C-14789988">selendroid-grid-plugin</a> and <a href="http://ios-driver-ci.ebaystratus.com/userContent/">ios-grid-plugin</a> plugins be downloaded and added to the Java classpath when starting the grid hub:</p>

						<pre><kbd class="bash">java -Dfile.encoding=UTF-8 -cp "selendroid-grid-plugin-{version}.jar:ios-grid-plugin-{version}.jar:selenium-server-standalone-{version}.jar" org.openqa.grid.selenium.GridLauncher -capabilityMatcher io.selendroid.grid.SelendroidCapabilityMatcher -role hub</kbd></pre>

						<aside class="tip"><p>When running on Windows, the colons (:) in the <kbd>-cp</kbd> argument must be replaced with semicolons (;).</p></aside>

						<p>Firefox, Safari, Chrome, Chrome for Android, and Internet Explorer will all be available using a standard Selenium server node. Selendroid and ios-driver, in contrast, use their own custom Selenium servers (<code>selendroid-standalone-{version}-with-dependencies.jar</code> and <code>ios-server-standalone-{version}.jar</code>), which must be run and registered separately with the hub. ios-driver uses the same hub registration method as the standard Selenium server (<kbd>-hub http://hub-server…</kbd>); Selendroid requires <a href="http://selendroid.io/scale.html#start">manual registration</a> to the hub.</p>
					</article>

					<article>
						<div class="a" id="execution-modes"></div>
						<h2 data-id="execution-modes">Running tests</h2>

						<div class="a half" id="browser-client"></div>
						<h3 data-id="browser-client">The browser client</h3>

						<p>The browser client allows unit tests to be run directly in a browser without any server other than a regular HTTP server. This is useful when you are in the process of writing unit tests that require a browser, or when you need to run a debugger in the browser to inspect a test failure.</p>

						<p>The browser client is loaded by navigating to <code>intern/client.html</code>. Assuming an Intern configuration file is located at <code>my-project/tests/intern</code>, a typical execution that runs all unit tests would look like this:</p>

						<pre><samp>http://localhost/my-project/node_modules/intern/client.html?
	config=tests/intern</samp></pre>

						<p>As can be seen from this example, because there is no concept of a “working directory” in URLs, the browser client chooses the directory two levels above <code>client.html</code> to be the root directory for the current test run. This can be overridden by specifying an <code>initialBaseUrl</code> argument:</p>

						<pre><samp>http://localhost/my-project/node_modules/intern/client.html?
	initialBaseUrl=/&amp;
	config=my-project/tests/intern</samp></pre>

						<p>Additional arguments to the browser client can be put in the query string. A more complex execution with arguments overriding the <a href="#option-suites">suites</a> and <a href="#option-reporters">reporters</a> properties from the configuration file might look like this:</p>

						<pre><samp>http://localhost/my-project/node_modules/intern/client.html?
	config=tests/intern&amp;
	suites=tests/unit/request&amp;
	suites=tests/unit/animation&amp;
	reporters=Console&amp;
	reporters=Html</samp></pre>

						<aside class="tip"><p>The browser client is also used by the <a href="#test-runner">test runner</a> to run unit tests in each browser.</p></aside>

						<p>The browser client supports the following arguments:</p>

						<table class="api">
							<thead>
								<tr>
									<th>Argument</th>
									<th>Description</th>
									<th>Default</th>
								</tr>
							</thead>
							<tr>
								<th scope="row">config</th>
								<td>The module ID of the Intern configuration file that should be used. Relative to <code>initialBaseUrl</code>. This argument is required.</td>
								<td>none</td>
							</tr>
							<tr>
								<th scope="row"><a href="#option-baseUrl">initialBaseUrl</a></th>
								<td>The path to use when resolving the <code>basePath</code> in a browser.</td>
								<td><code class="javascript">'node_modules/intern/../../'</code></td>
							</tr>
						</table>

						<div class="a half" id="option-baseUrl"></div>
						<h4>initialBaseUrl (string) <span class="versionBadge">3.0</span></h4>

						<p>The path to use when resolving the <code>basePath</code> in a browser. Since browsers do not have any concept of a current working directory, using this argument allows a pseudo-cwd to be specified for the browser client in order to match up file paths with what exists on the underlying filesystem. This argument should always be an absolute path (i.e. it should be the entire path that comes after the domain name).</p>

						<p>You can also specify any valid <a href="#configuration">configuration option</a> in the query string.</p>

						<div class="a half" id="node-client"></div>
						<h3 data-id="node-client">The Node.js client</h3>

						<p>The Node.js client allows unit tests to be run directly within a local Node.js environment. This is useful when you are writing unit tests for code that runs in Node.js. It is invoked by running <kbd>intern-client</kbd> on the command-line.</p>

						<p>A typical execution that runs all tests and outputs results to the console would look like this:</p>

						<pre><samp class="bash">intern-client config=tests/intern</samp></pre>

						<aside class="whatAreYouCrazy"><p>The <code>config</code> argument is a module ID, not a file path. Providing a file path may cause confusing or unpredictable results.</p></aside>

						<aside class="tip"><p>When running on Windows, all command-line options must be surrounded by quotes.</p></aside>

						<aside class="tip"><p>The commands shown above rely on npm being installed and configured properly. If your environment PATH is not set properly, you may need to run <kbd>node_modules/.bin/intern-client</kbd> instead of <kbd>intern-client</kbd>.</p></aside>

						<p>A more complex execution with arguments overriding the <a href="#option-suites">suites</a> and <a href="#option-reporters">reporters</a> properties from the configuration file might look like this:</p>

						<pre><samp class="bash">intern-client config=tests/intern suites=tests/unit/request \
	suites=tests/unit/animation \
	reporters=Console \
	reporters=LcovHtml</samp></pre>

						<p>The Node.js client supports the following arguments:</p>

						<table class="api">
							<tr>
								<th>Argument</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">config</th>
								<td>The module ID of the Intern configuration file that should be used. Relative to the current working directory. This argument is required.</td>
							</tr>
						</table>

						<p>You can also specify any valid <a href="#configuration">configuration option</a> as an argument on the command-line.</p>

						<div class="a half" id="test-runner"></div>
						<h3 data-id="test-runner">The test runner</h3>

						<p>The test runner allows functional tests to be executed against a Web browser or native mobile application. It also allows unit tests &amp; functional tests to be executed on multiple environments at the same time. This is useful when you want to automate UI testing, or when you want to run your entire test suite against multiple environments at once (for example, in <a href="#ci">continuous integration</a>). It is invoked by running <kbd>intern-runner</kbd> on the command-line.</p>

						<p>In order to use the test runner, you will need a WebDriver server. The WebDriver server is responsible for providing a way to control to all of the environments that you want to test. You can get a WebDriver server in one of a few different ways:</p>

						<ul>
							<li><a href="#local-selenium">By installing a copy of Selenium on your local machine</a></li>
							<li><a href="#hosted-selenium">By getting an account with a cloud-hosted Selenium provider</a></li>
							<li><a href="#selenium-grid">By setting up a distributed Selenium Grid</a></li>
						</ul>

						<p>A typical execution that runs all tests against all <a href="#option-environments">environments</a> and outputs aggregate test &amp; code coverage results to the console would look like this:</p>

						<pre><samp class="bash">intern-runner config=tests/intern</samp></pre>

						<aside class="whatAreYouCrazy"><p>The <code>config</code> argument is a module ID, not a file path. Providing a file path may cause confusing or unpredictable results.</p></aside>

						<aside class="tip"><p>When running on Windows, all command-line options must be surrounded by quotes.</p></aside>

						<aside class="tip"><p>The commands shown above rely on npm being installed and configured properly. If your environment PATH is not set properly, you may need to run <kbd>node_modules/.bin/intern-runner</kbd> instead of <kbd>intern-runner</kbd>.</p></aside>

						<p>A more complex execution that overrides the <a href="#option-reporters">reporters</a> and <a href="#option-functionalSuites">functionalSuites</a> properties from the configuration file might look like this:</p>

						<pre><samp class="bash">intern-runner config=tests/intern \
	reporters=Runner reporters=LcovHtml \
	functionalSuites=tests/functional/home \
	functionalSuites=tests/functional/cart</samp></pre>

						<aside class="tip"><p>The test runner is the <em>only</em> executor that runs functional tests.</p></aside>

						<p>The test runner supports the following arguments:</p>

						<table class="api">
							<tr>
								<th>Argument</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">config</th>
								<td>The module ID of the Intern configuration file that should be used. Relative to the current working directory. This argument is required.</td>
							</tr>
						</table>

						<p>You can also specify any valid <a href="#configuration">configuration option</a> as an argument on the command-line.</p>

						<div class="a half" id="custom-args"></div>
						<h3 data-id="custom-args">Using custom arguments</h3>

						<p>Intern allows arbitrary arguments to be passed on the command-line that can then be retrieved through the <!--<a href="TODO">-->main Intern object<!--</a>-->. This is useful for cases where you want to be able to pass things like custom ports, servers, etc. dynamically:</p>

						<pre><code class="javascript">define(function (require) {
	var intern = require('intern');

	// arguments object
	intern.args;
});</code></pre>

						<p>This makes it possible to, for example, define a dynamic proxy URL from the command-line or Grunt task:</p>

						<pre><code class="javascript">define(function (require) {
	var intern = require('intern');

	var SERVERS = {
		id1: 'http://id1.example/',
		id2: 'http://id2.example/'
	};

	return {
		proxyUrl: SERVERS[intern.args.serverId],

		// …additional configuration…
	};
});</code></pre>

						<pre><kbd class="bash">intern-runner config=tests/intern serverId=id1</kbd></pre>

						<aside class="tip"><p>In Intern 3, all arguments from the command-line are automatically added to the configuration object, so default configuration properties can be changed without needing to use custom arguments. For instance, in the previous example, <kbd class="bash">intern-runner config=tests/intern proxyUrl=http://id1.example/</kbd> could have been used instead of a custom argument.</p></aside>

						<div class="a half" id="grunt"></div>
						<h3 data-id="grunt">Using Grunt</h3>

						<p>Grunt support is built into Intern. Install Intern and load the Grunt task into your Gruntfile using <code class="javascript">grunt.loadNpmTasks('intern')</code>:</p>

						<pre><code class="javascript">module.exports = function (grunt) {
	// Load the Intern task
	grunt.loadNpmTasks('intern');

	// Configure tasks
	grunt.initConfig({
		intern: {
			someReleaseTarget: {
				options: {
					runType: 'runner', // defaults to 'client'
					config: 'tests/intern',
					reporters: [ 'Console', 'Lcov' ],
					suites: [ 'tests/unit/all' ]
				}
			},
			anotherReleaseTarget: { /* … */ }
		}
	});

	// Register a test task that uses Intern
	grunt.registerTask('test', [ 'intern' ]);

	// By default we just test
	grunt.registerTask('default', [ 'test' ]);
};</code></pre>

						<p>The following task options are available:</p>

						<table class="api">
							<tr>
								<th>Name</th>
								<th>Description</th>
								<th>Default</th>
							</tr>
							<tr>
								<th scope="row">browserstackAccessKey</th>
								<td>The access key for authentication with BrowserStack.</td>
								<td>none</td>
							</tr>
							<tr>
								<th scope="row">browserstackUsername</th>
								<td>The username for authentication with BrowserStack.</td>
								<td>none</td>
							</tr>
							<tr>
								<th scope="row">runType</th>
								<td>The execution mode in which Intern should run. This may be <code class="javascript">'runner'</code> for the <a href="#test-runner">test runner</a>, or <code class="javascript">'client'</code> for the <a href="#node-client">Node.js client</a>.</td>
								<td><code class="javascript">'client'</code></td>
							</tr>
							<tr>
								<th scope="row">sauceAccessKey</th>
								<td>The access key for authentication with Sauce Labs.</td>
								<td>none</td>
							</tr>
							<tr>
								<th scope="row">sauceUsername</th>
								<td>The username for authentication with Sauce Labs.</td>
								<td>none</td>
							</tr>
							<tr>
								<th scope="row">testingbotKey</th>
								<td>The API key for authentication with TestingBot.</td>
								<td>none</td>
							</tr>
							<tr>
								<th scope="row">testingbotSecret</th>
								<td>The API key for authentication with TestingBot.</td>
								<td>none</td>
							</tr>
						</table>

						<p>The following events are available:</p>

						<table class="api">
							<tr>
								<th>Event</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">intern.pass(message: string)</th>
								<td>This event is emitted when a test passes.</td>
							</tr>
							<tr>
								<th scope="row">intern.fail(message: string)</th>
								<td>This event is emitted when a test fails.</td>
							</tr>
						</table>

						<aside class="tip"><p>The current Grunt events are rudimentary, based on the output of the default <a href="#reporter-results">console reporter</a>, and do not provide much detail into the actual state of the test runner to Grunt tasks. Future versions of Intern are likely to improve to provide first-class event support, if sufficient demand exists for this feature.</p></aside>

						<div class="a half" id="gulp"></div>
						<h3 data-id="gulp">Using Gulp</h3>

						<p>Intern doesn’t provide a gulp plugin, but running Intern with gulp is much like running it with Grunt. The key difference is that Intern is run explicitly in gulp rather than through a plugin. The following example shows one way to do this</p>

						<pre><code class="javascript">gulp.task('test', function (done) {
	// Define the Intern command line
	var command = [
		'./node_modules/intern/runner.js',
		'config=tests/intern'
	];

	// Add environment variables, such as service keys
	var env = Object.create(process.env);
	env.BROWSERSTACK_ACCESS_KEY = '123456';
	env.BROWSERSTACK_USERNAME = 'foo@nowhere.com';

	// Spawn the Intern process
	var child = require('child_process').spawn('node', command, {
		// Allow Intern to write directly to the gulp process's stdout and
		// stderr.
		stdio: 'inherit',
		env: env
	});

	// Let gulp know when the child process exits
	child.on('close', function (code) {
		if (code) {
			done(new Error('Intern exited with code ' + code));
		}
		else {
			done();
		}
	});
});</code></pre>

						<p>Additional configuration options, such as <code>suites</code> and <code>reporters</code>, can be specified just as they would for a typical Intern <a href="#node-client">client</a> or <a href="#test-runner">runner</a> command line. Also, <code>spawn</code> isn’t a requirement. An Intern process has to be started, but some other library such as <code>gulp-shell</code> or <code>shelljs</code> could be used for this purpose. The only requirement is that the gulp task run Intern and be notified when it finishes.</p>
					</article>

					<article>
						<div class="a" id="reporters"></div>
						<h2 data-id="reporters">Getting test results</h2>

						<div class="a half" id="reporter-overview"></div>
						<h3 data-id="reporter-overview">Overview</h3>

						<p>Information about the state of a test run needs to be published in many different formats in order to properly integrate with different systems. To faciliate this, Intern allows reporters to be registered. A <dfn>reporter</dfn> is a simple object that receives messages from the rest of the test system and forwards that information, in the correct format, to a destination, like a file, console, or HTTP server.</p>

						<p>There are two primary kinds of reporters: reporters for <em>test results</em>, and reporters for <em>code coverage results</em>. Intern comes with a set of standard reporters, and also makes it easy to write your own <a href="#custom-reporters">custom reporters</a>.</p>

						<p>Reporters for a test run are defined using the <a href="#option-reporters">reporters</a> configuration option.</p>

						<div class="a half" id="reporter-results"></div>
						<h3 data-id="reporter-results">Test results reporters</h3>

						<p>Test results reporters provide information about the tests themselves—whether or not they passed, how long they took to run, and so on.</p>

						<p>Intern comes with several different test results reporters:</p>

						<table class="api">
							<tr>
								<th>Reporter</th>
								<th>Description</th>
								<th>Options</th>
							</tr>
							<tr>
								<th scope="row">Console</th>
								<td>This reporter outputs test pass/fail messages to the console or stdout, grouped by suite. It’s recommended that this reporter only be used by the browser and Node.js clients, and not the test runner, since it does not understand how to group results received from multiple different clients simultaneously.</td>
								<td>watermarks</td>
							</tr>
							<tr>
								<th scope="row">Html</th>
								<td>This reporter generates a basic HTML report of unit test results. It is designed to be used in the browser client, but can also generate reports in Node.js if a DOM-compatible document object is passed in.</td>
								<td>document</td>
							</tr>
							<tr>
								<th scope="row">JUnit</th>
								<td>This reporter generates a JUnit “compatible” XML file of unit test results.</td>
								<td>filename</td>
							</tr>
							<tr>
								<th scope="row">Pretty</th>
								<td>This reporter displays test progress across one or more environments with progress bars while testing is in progress. After all tests are finished, a sorted list of all tests is output along with an overall code coverage summary.</td>
								<td>watermarks</td>
							</tr>
							<tr>
								<th scope="row">Runner</th>
								<td>This reporter outputs information to the console about the current state of the runner, code coverage and test results for each environment tested, and a total test result. It can only be used in the test runner.</td>
								<td>filename,<br>watermarks</td>
							</tr>
							<tr>
								<th scope="row">TeamCity</th>
								<td>This reporter outputs test result information in a TeamCity-compatible format.</td>
								<td>filename</td>
							</tr>
						</table>

						<div class="a half" id="reporter-lcov"></div>
						<h3 data-id="reporter-lcov">Code coverage reporters</h3>

						<p>Code coverage reporters provide information about the state of code coverage—how many lines of code, functions, code branches, and statements were executed by the test system.</p>

						<p>Intern comes with several different test results reporters:</p>

						<table class="api">
							<tr>
								<th>Reporter</th>
								<th>Description</th>
								<th>Options</th>
							</tr>
							<tr>
								<th scope="row">Cobertura</th>
								<td>This reporter generates a Cobertura-compatible XML report from collated coverage data.</td>
								<td>filename,<br>watermarks</td>
							</tr>
							<tr>
								<th scope="row">Combined</th>
								<td>This reporter stores coverage data generated by the Node.js client in an intermediate file, and then merges in data generated by the WebDriver runner to generate a combined coverage report.</td>
								<td>directory,<br>watermarks</td>
							</tr>
							<tr>
								<th scope="row">Lcov</th>
								<td>This reporter generates an lcov.info from collated coverage data that can be fed to another program that understands the standard lcov data format.</td>
								<td>filename,<br>watermarks</td>
							</tr>
							<tr>
								<th scope="row">LcovHtml</th>
								<td>This reporter generates a set of illustrated HTML reports from collated coverage data.</td>
								<td>directory,<br>watermarks</td>
							</tr>
						</table>

						<aside class="tip"><p>Generally speaking, code coverage reporters will never work directly from the browser client because they require code to be instrumented in order to collect coverage data.</p></aside>

						<div class="a half" id="reporter-options"></div>
						<h3 data-id="reporter-options">Reporter options</h3>

						<p>As noted in the tables above, each reporter supports one or more different configuration options.</p>

						<table class="api">
							<tr>
								<th>Option</th>
								<th>Description</th>
								<th>Default</th>
							</tr>
							<tr>
								<th scope="row">directory</th>
								<td>The directory where output files should be written. This option is only used by reporters that need to write multiple files.</td>
								<td>varies by reporter</td>
							</tr>
							<tr>
								<th scope="row">document</th>
								<td>A DOM document.</td>
								<td><code class="javascript">window.document</code></td>
							</tr>
							<tr>
								<th scope="row">filename</th>
								<td>A filename where output should be written. If a filename is not provided, output will be sent to stdout.</td>
								<td>stdout</td>
							</tr>
							<tr>
								<th scope="row">watermarks</th>
								<td>The low &amp; high watermarks for code coverage results. Watermarks can be specified for statements, lines, functions, and branches. Normally, code coverage values below the low watermark appear in red, and code coverage values above the high watermark appear in green.</td>
								<td><code class="javascript" style="white-space: nowrap">{<br>
									&nbsp;&nbsp;statements: [ 50, 80 ],<br>
									&nbsp;&nbsp;lines: [ 50, 80 ],<br>
									&nbsp;&nbsp;functions: [ 50, 80 ],<br>
									&nbsp;&nbsp;branches: [ 50, 80 ]<br>
								}</code></td>
							</tr>
						</table>
					</article>

					<article>
						<div class="a" id="ci"></div>
						<h2 data-id="ci">Continuous integration</h2>

						<div class="a half" id="ci-jenkins"></div>
						<h3 data-id="ci-jenkins">Jenkins</h3>

						<p>When integrating Intern with Jenkins, there are two primary ways in which the integration can be completed: either creating a new project that executes as a post-build action for your primary project using a shared workspace, or by creating a multi-step free-style software project that executes Intern after the first (existing) build step.</p>

						<p>For projects that are already using Maven, a third option is to execute Intern using <a href="http://mojo.codehaus.org/exec-maven-plugin/"><code>exec-maven-plugin</code></a> from an existing <code>pom.xml</code>.</p>

						<p>When using Intern with Jenkins, use the <code>junit</code> reporter and enable the “Publish JUnit test result report” post-build action for the best test results display.</p>

						<p>To add code coverage data to Jenkins, add the <code>cobertura</code> reporter, install the Cobertura plugin for Jenkins, and enable the “Publish Cobertura Coverage Report” post-build action.</p>

						<h4>Intern as a post-build action to an existing project</h4>

						<p>This option enables you to use an existing build project by adding a new project that executes unit tests in a separate job from the main build. This option is ideal for situations where you want to be able to manage the build and testing processes separately, or have several projects that need to be built downstream from the main project that can occur in parallel with test execution.</p>

						<p>In order to accomplish this efficiently without the need to copy artifacts, use of the Shared Workspace plugin is recommended. To install and configure the Shared Workspace plugin, follow these steps:</p>

						<ol>
							<li>Install the Shared Workspace plugin from the Jenkins → Manage Jenkins → Manage Plugins page.</li>
							<li>Go to the Jenkins → Manage Jenkins → Configure System page.</li>
							<li>Under Workspace Sharing, add a new shared workspace. For the purposes of these instructions, this shared workspace will be called “myApp”.</li>
							<li>Save changes.</li>
						</ol>

						<p>Once the Shared Workspace plugin is installed, all projects that need to share the same workspace must be updated. The shared workspace for each project can be selected from the first section of the project’s configuration page.</p>

						<p>Once the main project is set to use the shared workspace, the new unit test project should be created:</p>

						<ol>
							<li>Create a new free-style software project, e.g. “myApp-tests”.</li>
							<li>At the top of the configuration, change the shared workspace to “myApp-tests”.</li>
							<li>Under “Source Code Management”, leave the “None” option checked. Because of the shared workspace, source code checkout will be handled by the upstream project.</li>
							<li>Under “Build triggers”, check the “Build after other projects are built” checkbox. Enter the name of the existing Maven project in the text box that appears. (This will create a corresponding post-build action to build “myApp-tests” in the existing project’s configuration.)</li>
							<li>Under “Build”, click the “Add build step” button and choose “Execute shell” from the drop-down.</li>
							<li>Under “Execute shell”, enter the command you want to use to run Intern. See the <a class="internal present" href="/theintern/intern/wiki/Running-Intern">Running tests</a> section for possible commands.</li>
							<li>Save changes.</li>
						</ol>

						<p>Once this project has been configured, test everything by running a build on the main project. Once the main project build finishes successfully, the new “myApp-tests” project will begin executing automatically.</p>

						<h4>Intern as part of a free-style software project</h4>

						<p>When working with an existing free-style software project it is possible to simply add the unit testing as an extra build step, following steps similar to the above:</p>

						<ol>
							<li>Open the configuration page for the existing free-style software project.</li>
							<li>Under “Build”, click the “Add build step” button and choose “Execute shell” from the drop-down.</li>
							<li>Under “Execute shell”, enter the command you want to use to run Intern. See the <a href="#runnin-intern">Running tests</a> section for possible commands.</li>
							<li>Save changes.</li>
						</ol>

						<h4>Intern as an execution step in a Maven pom.xml</h4>

						<p>Intern can be executed by Maven from a <code>pom.xml</code> during the test or integration-test phases of the build by using the <code>exec-maven-plugin</code> to spawn a new Intern process:</p>

						<pre><code class="xml">&lt;plugin>
	&lt;artifactId>exec-maven-plugin&lt;/artifactId>
	&lt;groupId>org.codehaus.mojo&lt;/groupId>
	&lt;version>1.2.1&lt;/version>
	&lt;executions>
			&lt;execution>
			&lt;id>run-tests&lt;/id>
			&lt;phase>test&lt;/phase>
			&lt;goals>
				&lt;goal>exec&lt;/goal>
			&lt;/goals>
		&lt;/execution>
	&lt;/executions>
	&lt;configuration>
		&lt;executable>node_modules/.bin/intern-runner&lt;/executable>
		&lt;arguments>
			&lt;argument>config=tests/intern&lt;/argument>
		&lt;/arguments>
	&lt;/configuration>
&lt;/plugin></code></pre>

						<p>The <code>executable</code> and <code>arguments</code> elements should be modified to run Intern using your desired executor and configuration.</p>

						<div class="a half" id="ci-travis"></div>
						<h3 data-id="ci-travis">Travis CI</h3>

						<p>In order to enable <a href="http://travis-ci.org/">Travis CI</a> builds for your project, you must first create a <code>.travis.yml</code> in your repository root that will load and execute Intern:</p>

						<pre><code class="hljs yaml"><span class="hljs-attribute">language:</span> <span class="hljs-value">node_js</span>
<span class="hljs-attribute">node_js:</span>
	- <span class="hljs-string">'0.10'</span>
<span class="hljs-attribute">script:</span> <span class="hljs-value">node_modules/.bin/intern-runner config=tests/intern</span></code></pre>

						<aside class="tip"><p>If you are using a cloud hosting provider like BrowserStack, Sauce Labs, or TestingBot, you can add <a href="#hosted-selenium">environment variables</a> holding your access credentials either through the Travis CI Web site by going to the repository’s settings page, or by <a href="http://docs.travis-ci.com/user/environment-variables/">adding an <code>env</code> list</a> to your .travis.yml configuration.</p></aside>

						<p>Once you have a Travis configuration, you just need to actually start the thing:</p>

						<ol>
							<li>Go to <a href="https://travis-ci.org/">https://travis-ci.org/</a></li>
							<li>Click “Sign in with GitHub” at the top-right</li>
							<li>Allow Travis CI to access your GitHub account</li>
							<li>Go to <a href="https://travis-ci.org/profile">https://travis-ci.org/profile</a></li>
							<li>Click “Sync now”, if necessary, to list all your GitHub projects</li>
							<li>Click the on/off switch next to the repository you want to test</li>
						</ol>

						<p>The next time you push commits to the repository, you will be able to watch Intern happily execute all your tests directly from the Travis CI Web site. Any time you make a new commit, or a new pull request is issued, Travis will automatically re-run your test suite and send notification emails on failure.</p>

						<div class="a half" id="ci-teamcity"></div>
						<h3 data-id="ci-teamcity">TeamCity</h3>

						<p>There are two primary ways that Intern can be integrated with a <a href="http://www.jetbrains.com/teamcity/">TeamCity</a> project: either by adding a new build configuration that is chained using a post-build trigger, or by adding additional build steps to an existing build configuration.</p>

						<p>When using Intern with TeamCity, use Intern’s <code>teamcity</code> reporter for best integration.</p>

						<h4>Intern as an additional build step</h4>

						<ol>
							<li>Go to the project that you want to add Intern to and click “Edit Project Settings” at the top-right.</li>
							<li>In the left-hand menu, click “General Settings”.</li>
							<li>Under “Build Configurations”, click “Edit” on the existing build configuration you want to add Intern to.</li>
							<li>In the left-hand menu, click “Build Steps”.</li>
							<li>Click “Add build step”.</li>
							<li>Select “Command Line” from the “Runner type” drop-down.</li>
							<li>Enter a name like “Run Intern” as the step name.</li>
							<li>Select “Custom Script” from the “Run” drop-down.</li>
							<li>Under “Custom script”, enter the command you want to use to run Intern. See the <a href="#running-intern">Running tests</a> section for possible commands.</li>
							<li>Click “Save”.</li>
						</ol>

						<h4>Intern as a separate build configuration</h4>

						<ol>
							<li>Go to the project that you want to add Intern to and click “Edit Project Settings” at the top-right.</li>
							<li>In the left-hand menu, click “General Settings”.</li>
							<li>Under “Build Configurations”, click “Create build configuration”.</li>
							<li>Enter a name like “Intern” as the build configuration name.</li>
							<li>Click “Save”.</li>
							<li>In the left-hand menu, click “Build Steps”.</li>
							<li>Click “Add build step”.</li>
							<li>Select “Command Line” from the “Runner type” drop-down.</li>
							<li>Enter a name like “Run Intern” as the step name.</li>
							<li>Select “Custom Script” from the “Run” drop-down.</li>
							<li>Under “Custom script”, enter the command you want to use to run Intern. See the <a href="#running-intern">Running tests</a> section for possible commands.</li>
							<li>Click “Save”.</li>
							<li>Go back to the settings page for the project.</li>
							<li>In the left-hand menu, click “General Settings”.</li>
							<li>Click “Edit” on the build configuration you want to trigger Intern from.</li>
							<li>In the left-hand menu, click “Triggers”.</li>
							<li>Click “Add new trigger”.</li>
							<li>Choose “Finish Build Trigger” from the drop-down.</li>
							<li>Under “Build configuration”, choose the Intern build configuration that was just created.</li>
							<li>Check “Trigger after successful build only”.</li>
							<li>Click “Save”.</li>
						</ol>

						<div class="a half" id="ci-codeship"></div>
						<h3 data-id="ci-codeship">Codeship</h3>

						<p>To use Intern with <a href="https://codeship.com/">Codeship</a>, you’ll need to configure a test pipeline:</p>

						<h4>For a new project:</h4>

						<ol>
							<li>Log in to Codeship.</li>
							<li>In the upper-left corner, click “Select Project...”.</li>
							<li>Click the “Create a new project” button.</li>
							<li>Connect your GitHub or Bitbucket account as required.</li>
							<li>Choose the repository you’d like to test.</li>
							<li>Select “I want to create my own custom commands” from the dropdown box labeled “Select your technology to prepopulate basic commands”.</li>
							<li>The following steps are the same as for an existing project.</li>
							<li>Once completed, click “Save and go to dashboard” and then push a commit to see your build tested.</li>
						</ol>

						<h4>For an existing project:</h4>

						<ol>
							<li>Log in to Codeship.</li>
							<li>In the upper-left corner, click “Select Project...”.</li>
							<li>Select the gear icon to the right of your project’s name.</li>
							<li>From the “Test” Project Settings page, select “I want to create my own custom commands” from the dropdown box labeled “Select your technology to prepopulate basic commands”.</li>
							<li>The remaining steps are identical to creating any new project with Codeship.</li>
						</ol>

						<h4>Setup Commands</h4>

						<p>Setup Commands are those that allow you to set up your environment. For testing a project with Intern, you must install node and your project’s dependencies:
							<pre><code class="bash">
# Install the version of node specified in your package.json
nvm install node

# Install project requirements
npm install
							</code></pre>
						</p>

						<h4>Configure Test Pipelines</h4>

						<p>The test pipeline is what actually runs your specified test commands. This is equivalent to running the tests on your local development environment. For example, to run the Intern self-tests with the <code>intern-client</code>, you would enter the following command:
							<pre><code class="bash">
# run the intern-client with the specified configuration
node_modules/.bin/intern-client config=tests/selftest.intern.js
							</code></pre>
						</p>

						<p>If you want to run tests with Selenium, Codeship supports this as well! You just need to <a href="https://github.com/codeship/scripts/blob/master/packages/selenium_server.sh">curl and run this script</a> before calling the <code>intern-runner</code> with a <code>NullTunnel</code>.
							<pre><code class="bash">
curl -sSL https://raw.githubusercontent.com/codeship/scripts/master/packages/selenium_server.sh | bash -s
node_modules/.bin/intern-runner config=tests/selftest.intern.js tunnel=NullTunnel
							</code></pre>
					</p>

					<div class="a half" id="ci-bamboo"></div>
					<h3 data-id="ci-bamboo">Bamboo</h3>

					<p>Using Intern with Bamboo involves creating a build plan, described below. Note that the instructions below were tested using Bamboo Cloud edition, but configuring a build plan task should work similarly using a local agent.</p>

					<h4>Manage elastic instances</h4>

					<p>By default, if you run a build on Bamboo and an agent isn’t available, an Elastic Bamboo image is started as a Windows Server instance. Intern behavior is more consistent running in a POSIX compliant environment, so follow the steps below to create a Linux instance:</p>

					<ol>
						<li>From the gear icon menu in the upper-right corner of any Bamboo administration page, select “Elastic instances”.</li>
						<li>Click the “Start new elastic instances” button in the upper-right corner of the page.</li>
						<li>Under the “Elastic image configuration name” dropdown, select “Ubuntu stock image”.</li>
						<li>Click the “Submit” button.</li>
					</ol>

					<p>You will be taken to the “Manage elastic instances” page, where you will see your image and its current state. Once the image status is “Running”, the Elastic Agent starts. Once the agent has started and is either “Pending” or “Idle”, you may begin your build.</p>

					<h4>Create a build plan</h4>

					<ol>
						<li>Click the “Create” dropdown button at the top-middle of any Bamboo administration page.</li>
						<li>Select “Create a new plan” from the menu.</li>
						<li>Select or create a Project to house the build plan.</li>
						<li>Give the build plan a name and key, for your reference, and provide an optional description.</li>
						<li>Link the build plan to a previously linked or new repository.</li>
						<li>Click “Configure plan”.</li>
					</ol>

					<h4>Configure your build plan</h4>

					<p>By default, the plan starts with an initial task of “Source Code Checkout”, which you can leave configured as is, because you linked the repository in a previous step.</p>

					<ol>
						<li>Add a task of “npm”.</li>
						<li>Use Node.js executable “Node.js 0.12” (or newer).</li>
						<li>Provide it with a Command of “install” and save the task.</li>
						<li>Add a task of “Script”.</li>
						<li>In the script body, write the following (use the version of node chosen in step 2):
							<pre><code>
/opt/node-0.12/bin/node ${bamboo.build.working.directory}/node_modules/.bin/intern-client \
	config=tests/selftest.intern \
	reporters=JUnit \
	> results.xml
							</code></pre>
						</li>
						<li>Save the Script task.</li>
						<li>Add a task of “JUnit Parser”.</li>
						<li>Enter “*” in the “Specify custom results directories” field and save the task.</li>
						<li>Below the task configuration interface, make sure “Yes please!” is checked under the “Enable this plan?” heading.</li>
						<li>Click the “Create” button to create your build plan.</li>
					</ol>

					<h4>Running your build plan and verifying its output</h4>

					<ol>
						<li>Click the “Build” dropdown menu item from the Bamboo administration page top menu and select “All build plans”.</li>
						<li>Select your plan from those shown.</li>
						<li>Click “Run” and then “Run plan” in the upper-right corner of the page.</li>
						<li>Once your plan has finished running, you will see a “Tests” tab on the page, which you can click through and see details of every test.</li>
					</ol>

					</article>

					<article>
						<div class="a" id="customisation"></div>
						<h2 data-id="customisation">Customisation</h2>

						<div class="a half" id="custom-interfaces"></div>
						<h3 data-id="custom-interfaces">Custom interfaces</h3>

						<p>Custom interfaces allow Intern to understand test files written for other testing systems—and even other languages! If you want to use Intern but don’t want to spend time and energy converting tests you’ve already written for another test system, writing a custom interface may be the quickest solution.</p>

						<p>Any interface in Intern, including a custom interface, is responsible for doing three things:</p>

						<ol>
							<li>Creating new instances of <a href="#suite-object"><code>intern/lib/Suite</code></a> for each test suite defined in the test file</li>
							<li>Creating new instances of <a href="#test-object"><code>intern/lib/Test</code></a> for each test function defined in the test file, and associating it with a suite</li>
							<li>Calling <code>intern.executor.register</code> to register all of the suites generated by the test interface with the test executor</li>
						</ol>

						<p><code>intern.executor.register</code> takes a callback that will be called by the executor. The callback will be passed a Suite object that it should register tests on. For unit tests, the callback will normally be called only once. For functional tests, the callback will be called once for each remote environment.</p>

						<p>There are two ways to write test interfaces: as standard modules, or as loader plug-ins.</p>

						<h4>As a standard module (for tests written in JavaScript)</h4>

						<p>A standard module is a normal AMD module that returns a test interface.</p>

						<p>A very basic custom interface that lets users register test functions by calling <code>addTest</code> looks like this:</p>

						<pre><code class="javascript">// in tests/support/customInterface.js
define(function (require) {
	var intern = require('intern');
	var Test = require('intern/lib/Test');

	return {
		// Whenever `addTest` is called on this interface…
		addTest: function (name, testFn) {
			// …the test function is registered on each of the root
			// suites defined by the test executor
			intern.executor.register(function (suite) {
				// The interface is responsible for creating a Test object
				// representing the test function and associating it with
				// the correct parent suite
				var test = new Test({ name: name, test: testFn, parent: suite });
				suite.tests.push(test);
			});
		}
	};

	// That’s it!
});</code></pre>

						<p>This custom interface can then be used by any test module simply by requiring and using it the same way you’d use one of the built-in test interfaces:</p>

						<pre><code class="javascript">// in tests/unit/test.js
define(function (require) {
	var interface = require('../support/customInterface');
	var assert = require('intern/chai!assert');

	interface.addTest('my test', function () {
		assert.ok(true);
	});
});</code></pre>

						<p>Interfaces can also create nested suites by creating Suite objects:</p>

						<pre><code class="javascript">// in tests/support/suiteInterface.js
define(function (require) {
	var intern = require('intern');
	var Suite = require('intern/lib/Suite');
	var Test = require('intern/lib/Test');

	return {
		// Whenever `createSuite` is called on this interface…
		createSuite: function (name) {
			var suites = [];

			// …one or more new suites are created and registered
			// with each of the root suites from the executor…
			intern.executor.register(function (rootSuite) {
				var suite = new Suite({ name: name, parent: rootSuite });

				// (Sub-suites are pushed to the `tests` array of their
				// parent suite, same as tests)
				rootSuite.tests.push(suite);

				suites.push(suite);
			});

			// …and a new object is returned that allows test functions
			// to be added to the newly created suite(s)
			return {
				addTest: function (name, testFn) {
					suites.forEach(function (suite) {
						var test = new Test({ name: name, test: testFn, parent: suite });
						suite.tests.push(test);
					});
				}
			};
		}
	};
});</code></pre>

						<p>This custom interface would then be used like this:</p>

						<pre><code class="javascript">// in tests/unit/test2.js
define(function (require) {
	var interface = require('../support/suiteInterface');
	var assert = require('intern/chai!assert');

	var suite = interface.createSuite('my suite');
	suite.addTest('my test', function () {
		assert.ok(true);
	});
});</code></pre>

						<aside class="whatAreYouCrazy"><p>Test and Suite constructors must always be passed <code>name</code> and <code>parent</code> properties, since this information is used at construction time to notify reporters of a new suite or test.</p></aside>

						<p>As a more practical (but incomplete) example, to convert a Jasmine test suite to an Intern test suite using a custom Jasmine interface, you’d simply run a script to wrap all of your existing Jasmine spec files like this:</p>

						<pre><code class="javascript">// in tests/unit/jasmineTest.js
define(function (require) {
	var jasmine = require('../support/jasmineInterface');

	// you could also just use `with (jasmine) {}` if you want
	var describe = jasmine.describe, it = jasmine.it, expect = jasmine.expect, beforeEach = jasmine.beforeEach, afterEach = jasmine.afterEach, xdescribe = jasmine.xdescribe, xit = jasmine.xit, fdescribe = jasmine.fdescribe, fit = jasmine.fit;

	// existing test code goes here
});</code></pre>

						<p>Then, you’d only need to write a custom Jasmine test interface that creates Intern Suite and Test objects and registers them with the current executor. In this case, since the Jasmine API is so similar to Intern’s TDD API, it’s possible to leverage one of the built-in interfaces instead of having to do it all ourselves:</p>

						<pre><code class="javascript">// in tests/support/jasmineInterface.js
define(function (require) {
	var tdd = require('intern!tdd');

	// This function creates an object that looks like a Jasmine Suite and
	// translates back to the native Intern Suite object type
	function createJasmineCompatibleSuite(suite) {
		return {
			disable: function () {
				suite.tests.forEach(function (test) {
					test.skip('Disabled');
				});
			},
			getFullName: function () {
				return suite.id;
			},
			// …
		};
	}

	// This function creates an object that looks like a Jasmine spec and
	// translates back to the native Intern Test object type
	function createJasmineCompatibleSpec(test) {
		return {
			disable: function () {
				test.skip('Disabled');
			},
			status: function () {
				if (test.skipped != null) {
					return 'disabled';
				}

				if (test.timeElapsed == null) {
					return 'pending';
				}

				if (test.error) {
					return 'failed';
				}

				return 'passed';
			},
			// …
		};
	}

	// This function wraps a Jasmine suite factory so that when it is invoked
	// it gets a `this` context that looks like a Jasmine suite
	function wrapJasmineSuiteFactory(factory) {
		return function () {
			var jasmineSuite = createJasmineCompatibleSuite(this);
			factory.call(jasmineSuite);
		};
	}

	// This function wraps a Jasmine spec so when it is invoked it gets a
	// `this` context that looks like a Jasmine spec and supports Jasmine’s
	// async API
	function wrapJasmineTest(test) {
		return function () {
			var jasmineTest = createJasmineCompatibleSpec(test);
			if (test.length === 1) {
				return new Promise(function (resolve) {
					test.call(jasmineTest, resolve);
				});
			}
			else {
				test.call(jasmineTest);
			}
		};
	}

	return {
		// When `describe` is called on the Jasmine interface…
		describe: function (name, factory) {
			// …route it through to Intern, wrapping the factory as needed
			// so it will work correctly in Intern
			tdd.suite(name, wrapJasmineSuiteFactory(factory));
		},

		// When `it` is called on the Jasmine interface…
		it: function (name, spec) {
			// …route it through to Intern, wrapping the test function
			// so it will work correctly in Intern
			tdd.test(name, wrapJasmineTest(spec));
		},

		// continue to translate the Jasmine API until tests run…

		// …
	};
});</code></pre>

						<aside class="tip"><p>The <a href="https://github.com/theintern/intern/tree/master/lib/interfaces">built-in interfaces</a> can also be used as a reference to understand how to better create a custom interface.</p></aside>

						<h4>As a loader plugin (for tests written in other languages)</h4>

						<p>For tests written in other languages, an AMD <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">loader plugin</a> can be used instead of a normal module to asynchronously parse and compile the foreign source code into a JavaScript function that can be called by an Intern Test object:</p>

						<pre><code class="javascript">// in tests/support/javaInterface.js
define(function () {
	var text = require('intern/dojo/text');
	var parser = require('tests/support/javaTestParser');
	var intern = require('intern');
	var Test = require('intern/lib/Test');

	// Return an AMD loader plugin…
	return {
		// When the plugin is requested as a dependency…
		load: function (resourceId, require, load) {
			// …load the associated resource ID…
			text.load(resourceId, function (code) {
				// …then use a parser to convert the raw test code into
				// a list of test names and functions…
				var tests = parser.parse(code);

				// …then register each test function with Intern…
				tests.forEach(function (testNode) {
					intern.executor.register(function (suite) {
						var test = new Test({
							name: testNode.name,
							test: testNode.fn,
							parent: suite
						});
						suite.tests.push(test);
					});
				});

				// …then tell the module loader that the everything is done loading
				load();
			});
		}
	};
});</code></pre>

						<p>To use a plugin-based test interface like this, use the AMD loader plugin syntax in your Intern configuration:</p>

						<pre><code class="javascript">// in intern.js
define({
	suites: [
		// load `tests/unit/test.java` using `tests/support/javaInterface`
		'tests/support/javaInterface!tests/unit/test.java'
	],
	functionalSuites: [
		// load `tests/functional/test.java` using `tests/support/javaInterface`
		'tests/support/javaInterface!tests/functional/test.java'
	]
});</code></pre>

						<div class="a half" id="custom-executors"></div>
						<h3 data-id="custom-executors">Custom executors <span class="versionBadge">3.0</span></h3>

						<p>TODO</p>

						<div class="a half" id="custom-reporters"></div>
						<h3 data-id="custom-reporters">Custom reporters</h3>

						<p>If none of the <a href="#reporter-overview">built-in reporters</a> provide the information you need, you can write a custom reporter and reference it using an absolute module ID (i.e. <code class="javascript">'tests/support/CustomReporter'</code>).</p>

						<p><span class="versionBadge">3.0</span> Reporters in Intern are JavaScript constructors. When instantiated, a reporter receives the configuration data provided by the user in their <a href="#option-reporters">reporters</a> configuration, along with the following special properties:</p>

						<table class="api">
							<tr>
								<th>Property</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">console</th>
								<td>An object that provides the basic <a href="https://developer.mozilla.org/en-US/docs/Web/API/console">Console API</a> for reporters that want to provide enhanced console-based output.</td>
							</tr>
							<tr>
								<th scope="row">output</th>
								<td>A Writable stream where output data should be sent by calling <code>output.write(data)</code>. This stream will automatically be closed by Intern at the end of the test run. Most reporters should use this mechanism for outputting data.</td>
							</tr>
						</table>

						<p>Reporters should implement one or more of the following methods, which will be called by Intern when an event occurs:</p>

						<table class="api">
							<tr>
								<th>Method</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">coverage(<br>&nbsp;&nbsp;sessionId: string,<br>&nbsp;&nbsp;data: Object<br>)</th>
								<td>This method is called when code coverage data has been retrieved from an environment. This will occur once per remote environment when all unit tests have completed, and again any time a new page is loaded. Each unique <code>sessionId</code> corresponds to a single remote environment. <code>sessionId</code> will be <code>null</code> for a local environment (for example, in the Node.js client).</td>
							</tr>
							<tr>
								<th scope="row">deprecated(<br>&nbsp;&nbsp;name: string,<br>&nbsp;&nbsp;replacement?: string,<br>&nbsp;&nbsp;extra?: string<br>)</th>
								<td>This method is called when a deprecated function is called.</td>
							</tr>
							<tr>
								<th scope="row">fatalError(error: Error)</th>
								<td>This method is called when an error occurs within the test system that is non-recoverable (for example, a bug within Intern).</td>
							</tr>
							<tr>
								<th scope="row">newSuite(suite: Suite)</th>
								<td>This method is called when a new test suite is created.</td>
							</tr>
							<tr>
								<th scope="row">newTest(test: Test)</th>
								<td>This method is called when a new test is created.</td>
							</tr>
							<tr>
								<th scope="row">proxyEnd(config: Proxy)</th>
								<td>This method is called once the built-in HTTP server has finished shutting down.</td>
							</tr>
							<tr>
								<th scope="row">proxyStart(config: Proxy)</th>
								<td>This method is called once the built-in HTTP server has finished starting up.</td>
							</tr>
							<tr>
								<th scope="row">reporterError(<br>&nbsp;&nbsp;reporter: Reporter,<br>&nbsp;&nbsp;error: Error<br>)</th>
								<td>This method is called when a reporter throws an error during execution of a command. If a reporter throws an error in response to a <code>reporterError</code> call, it will not be called again to avoid infinite recursion.</td>
							</tr>
							<tr>
								<th scope="row">runEnd(executor: Executor)</th>
								<td>This method is called after all test suites have finished running and the test system is preparing to shut down.</td>
							</tr>
							<tr>
								<th scope="row">runStart(executor: Executor)</th>
								<td>This method is called after all tests have been registered and the test system is about to begin running tests.</td>
							</tr>
							<tr>
								<th scope="row">suiteEnd(suite: Suite)</th>
								<td>This method is called when a test suite has finished running.</td>
							</tr>
							<tr>
								<th scope="row">suiteError(<br>&nbsp;&nbsp;suite: Suite,<br>&nbsp;&nbsp;error: Error<br>)</th>
								<td>This method is called when an error occurs within one of the suite’s lifecycle methods (setup, beforeEach, afterEach, or teardown), or when an error occurs when a suite attempts to run a child test.</td>
							</tr>
							<tr>
								<th scope="row">suiteStart(suite: Suite)</th>
								<td>This method is called when a test suite starts running.</td>
							</tr>
							<tr>
								<th scope="row">testEnd(test: Test)</th>
								<td>This method is called when a test has finished running.</td>
							</tr>
							<tr>
								<th scope="row">testFail(test: Test)</th>
								<td>This method is called when a test has failed.</td>
							</tr>
							<tr>
								<th scope="row">testPass(test: Test)</th>
								<td>This method is called when a test has passed.</td>
							</tr>
							<tr>
								<th scope="row">testSkip(test: Test)</th>
								<td>This method is called when a test has been skipped.</td>
							</tr>
							<tr>
								<th scope="row">testStart(test: Test)</th>
								<td>This method is called when a test starts running.</td>
							</tr>
							<tr>
								<th scope="row">tunnelDownloadProgress(<br>&nbsp;&nbsp;tunnel: Tunnel,<br>&nbsp;&nbsp;progress: Object<br>)</th>
								<td>This method is called every time a tunnel download has progressed. The <code>progress</code> object contains <code>loaded</code> (bytes received) and <code>total</code> (bytes to download) properties.</td>
							</tr>
							<tr>
								<th scope="row">tunnelEnd(tunnel: Tunnel)</th>
								<td>This method is called after the WebDriver server tunnel has shut down.</td>
							</tr>
							<tr>
								<th scope="row">tunnelStart(tunnel: Tunnel)</th>
								<td>This method is called immediately before the WebDriver server tunnel is started.</td>
							</tr>
							<tr>
								<th scope="row">tunnelStatus(<br>&nbsp;&nbsp;tunnel: Tunnel,<br>&nbsp;&nbsp;status: string<br>)</th>
								<td>This method is called whenever the WebDriver server tunnel reports a status change.</td>
							</tr>
						</table>

						<p>A reporter can return a Promise from any of these methods, which will cause the test system to pause at that point until the Promise has been resolved. The behaviour of a rejected reporter Promise is currently undefined.</p>

						<p>For backwards-compatibility, you can also create reporters using the deprecated Intern 2 format, where the reporter itself is a single JavaScript object that uses topic names as keys and functions as values:</p>

						<pre><code class="javascript">define(function (require) {
	return {
		'/test/start': function (test) {
			console.log(test.id + ' started');
		},
		'/test/end': function (test) {
			console.log(test.id + ' ended');
		}
	};
});</code></pre>

						<p>Legacy reporters can also include optional <code>start</code> and <code>stop</code> methods for performing any additional arbitrary work when a reporter is started or stopped:</p>

						<pre><code class="javascript">define(function (require) {
	var aspect = require('dojo/aspect');
	var Suite = require('intern/lib/Suite');

	var handles = [];
	return {
		start: function () {
			function augmentJsonValue() {
				/* … */
			}

			handles.push(aspect.after(Suite.prototype, 'toJSON', augmentJsonValue));
		},

		stop: function () {
			var handle;
			while ((handle = handles.pop())) {
				handle.remove();
			}
		}
	}
});</code></pre>

						<p>Events from the list above will be converted to topics for legacy reporters as follows:</p>

						<table>
							<tr>
								<th>Event</th>
								<th>Topic</th>
							</tr>
							<tr>
								<td>coverage</td>
								<td>/coverage</td>
							</tr>
							<tr>
								<td>deprecated</td>
								<td>/deprecated</td>
							</tr>
							<tr>
								<td>fatalError</td>
								<td>/error</td>
							</tr>
							<tr>
								<td>newSuite</td>
								<td>/suite/new</td>
							</tr>
							<tr>
								<td>newTest</td>
								<td>/test/new</td>
							</tr>
							<tr>
								<td>runEnd</td>
								<td>/client/end<br>/runner/end<br>stop (method)</td>
							</tr>
							<tr>
								<td>runStart</td>
								<td>/runner/start<br>start (method)</td>
							</tr>
							<tr>
								<td>suiteEnd</td>
								<td>/suite/end</td>
							</tr>
							<tr>
								<td>suiteError</td>
								<td>/suite/error</td>
							</tr>
							<tr>
								<td>suiteStart</td>
								<td>/suite/start</td>
							</tr>
							<tr>
								<td>testEnd</td>
								<td>/test/end</td>
							</tr>
							<tr>
								<td>testFail</td>
								<td>/test/fail</td>
							</tr>
							<tr>
								<td>testPass</td>
								<td>/test/pass</td>
							</tr>
							<tr>
								<td>testSkip</td>
								<td>/test/skip</td>
							</tr>
							<tr>
								<td>testStart</td>
								<td>/test/start</td>
							</tr>
							<tr>
								<td>testFail</td>
								<td>/test/fail</td>
							</tr>
							<tr>
								<td>tunnelDownloadProgress</td>
								<td>/tunnel/download/progress</td>
							</tr>
							<tr>
								<td>tunnelEnd</td>
								<td>/tunnel/stop</td>
							</tr>
							<tr>
								<td>tunnelStart</td>
								<td>/tunnel/start</td>
							</tr>
							<tr>
								<td>tunnelStatus</td>
								<td>/tunnel/status</td>
							</tr>
						</table>
					</article>

					<article>
						<div class="a" id="internals"></div>
						<h2 data-id="internals">Internals</h2>

						<div class="a half" id="suite-object"></div>
						<h3 data-id="suite-object">The Suite object</h3>

						<p>The <a href="https://github.com/theintern/intern/blob/master/lib/Suite.js"><dfn>Suite object</dfn></a> represents a logical grouping of tests within a test run. When inside a setup (a.k.a. “before”), beforeEach, afterEach, or teardown (a.k.a. “after”) method, the <code class="javascript">this</code> object will be the Suite object that represents that suite.</p>

						<p>The following properties and methods are available on all Suite objects:</p>

						<table class="api">
							<tr>
								<th>Property</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">error</th>
								<td>An Error object containing any error thrown from one of the suite lifecycle methods.</td>
							</tr>
							<tr>
								<th scope="row">grep</th>
								<td>A RegExp that will be used to skip tests. This value will be inherited from the parent suite. See the <a href="#option-grep">grep configuration option</a> for more information.</td>
							</tr>
							<tr>
								<th scope="row">id</th>
								<td>The unique identifier string for this suite. This property is read-only.</td>
							</tr>
							<tr>
								<th scope="row">name</th>
								<td>A string representing the human-readable name of the suite.</td>
							</tr>
							<tr>
								<th scope="row">numTests</th>
								<td>The total number of tests registered in this suite and its sub-suites. (To get just the number of tests for this suite, use <code class="javascript">tests.length</code>.)</td>
							</tr>
							<tr>
								<th scope="row">numFailedTests</th>
								<td>The number of failed tests in this suite and its sub-suites.</td>
							</tr>
							<tr>
								<th scope="row">numSkippedTests</th>
								<td>The number of skipped tests in this suite and its sub-suites.</td>
							</tr>
							<tr>
								<th scope="row">parent</th>
								<td>The parent suite, if this suite is a sub-suite. This property will be <code class="javascript">null</code> for unit tests that have been sent from a client back to the test runner.</td>
							</tr>
							<tr>
								<th scope="row">publishAfterSetup</th>
								<td>When set to <code class="javascript">false</code> (the default), the suiteStart event is sent before the setup method runs and the suiteEnd event is sent after the teardown method has finished running. Setting this value to <code class="javascript">true</code> flips when the suiteStart and suiteEnd events are sent to reporters so suiteStart is sent <em>after</em> setup is finished and suiteEnd is sent <em>before</em> teardown is finished.</td>
							</tr>
							<tr>
								<th scope="row">remote</th>
								<td>A <a href="https://theintern.github.io/leadfoot/Command.html">Leadfoot Command object</a> that can be used to drive a remote environment. This value will be inherited from the parent suite. Only available to suites that are loaded from <a href="#option-functionalSuites">functionalSuites</a>.</td>
							</tr>
							<tr>
								<th scope="row">reporterManager <span class="versionBadge">3.0</span></th>
								<td>The event hub that can be used to send result data and other information to <a href="#reporter-overview">reporters</a>. This value will be inherited from the parent suite.</td>
							</tr>
							<tr>
								<th scope="row">sessionId</th>
								<td>A unique identifier for a remote environment session. This value will be inherited from the parent suite. Only available to suites that are loaded from <a href="#option-functionalSuites">functionalSuites</a>.</td>
							</tr>
							<tr>
								<th scope="row">timeElapsed</th>
								<td>Time, in milliseconds, that the suite took to execute. Only available once all tests in the suite have finished running.</td>
							</tr>
							<tr>
								<th scope="row">tests</th>
								<td>An array of Test or Suite objects. Push more tests/suites onto this object before a test run begins to populate the test system with tests. The behaviour of adding tests after a test run has begun is undefined.</td>
							</tr>
						</table>

						<table class="api">
							<tr>
								<th>Method</th>
								<th>Description</th>
							</tr>
							<tr id="suite-object-afterEach">
								<th scope="row">afterEach(test: Test <span class="versionBadge">3.0</span>):<br>&nbsp;&nbsp;Promise&lt;void></th>
								<td>A function which will be executed after each test in the suite, including nested, skipped, and failed tests. If a Promise is returned, the suite will wait until the Promise is resolved before continuing. If the Promise rejects, the test will be considered failed and the error from the Promise will be used as the error for the Test.</td>
							</tr>
							<tr id="suite-object-beforeEach">
								<th scope="row">beforeEach(test: Test <span class="versionBadge">3.0</span>):<br>&nbsp;&nbsp;Promise&lt;void></th>
								<td>A function which will be executed before each test in the suite, including nested tests. If a Promise is returned, the suite will wait until the Promise is resolved before continuing. If the Promise rejects, the test will be considered failed and the error from the Promise will be used as the error for the Test.</td>
							</tr>
							<tr>
								<th scope="row">run(): Promise&lt;number></th>
								<td>Runs the test suite. Returns a Promise that resolves to the number of failed tests after all tests in the suite have finished running.</td>
							</tr>
							<tr id="suite-object-setup">
								<th scope="row">setup(): Promise&lt;void></th>
								<td>A function which will be executed once when the suite starts running. If a Promise is returned, the suite will wait until the Promise is resolved before continuing. If the Promise rejects, the suite will be considered failed and the error from the Promise will be used as the error for the Suite.</td>
							</tr>
							<tr id="suite-object-teardown">
								<th scope="row">teardown(): Promise&lt;void></th>
								<td>A function which will be executed once after all tests in the suite have finished running. If a Promise is returned, the suite will wait until the Promise is resolved before continuing. If the Promise rejects, the suite will be considered failed and the error from the Promise will be used as the error for the Suite.</td>
							</tr>
							<tr>
								<th scope="row">toJSON(): Object</th>
								<td>Returns an object that can be safely serialised to JSON. This method normally does not need to be called directly; <code>JSON.stringify</code> will use the <code>toJSON</code> method automatically if you try to serialise the Suite object.</td>
							</tr>
						</table>

						<p><span class="versionBadge">3.1</span> Within the lifecycle methods (<code>setup/before</code>, <code>beforeEach</code>, <code>afterEach</code>, <code>teardown/after</code>), an <code>async</code> method is available that can be used in lieu of returning a Promise. For example:</p>

						<pre><code class="javascript">setup: function () {
	var dfd = this.async(1000); 
	fs.readFile(filename, function (data) {
		testData = data;
		dfd.resolve();
	});
}</code></pre>
						
						<p><code>async</code> returns an augmented Deferred object (see <a href="#async-tests">asynchronous tests</a> for more information). The lifecycle method in which <code>async</code> was called will wait for the Deferred to resolve, just as if a Promise were returned. The main difference between using the <code>async</code> method and returning a Promise is that <code>async</code> allows the method’s timeout to be configured with an optional number of milliseconds.</p>

						<div class="a half" id="test-object"></div>
						<h3 data-id="test-object">The Test object</h3>

						<p>The <a href="https://github.com/theintern/intern/blob/master/lib/Test.js"><dfn>Test object</dfn></a> represents a single test within a test run. When inside a test function, the <code class="javascript">this</code> object will be the Test object that represents that test.</p>

						<p>The following properties and methods are available on all Test objects:</p>

						<table class="api">
							<tr>
								<th>Property</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">error</th>
								<td>If a test fails, the error that caused the failure will be available here.</td>
							</tr>
							<tr>
								<th scope="row">id</th>
								<td>The unique identifier string for this test. This property is read-only.</td>
							</tr>
							<tr>
								<th scope="row">isAsync</th>
								<td>A flag representing whether or not this test is asynchronous. This flag will not be set until the test function actually runs.</td>
							</tr>
							<tr>
								<th scope="row">name</th>
								<td>A string representing the human-readable name of the suite.</td>
							</tr>
							<tr>
								<th scope="row">parent</th>
								<td>The parent suite for the test. This property must be set by the test interface that instantiates the Test object. This property will be <code class="javascript">null</code> for unit tests that have been sent from a client back to the test runner.</td>
							</tr>
							<tr>
								<th scope="row">remote</th>
								<td>A <a href="https://theintern.github.io/leadfoot/Command.html">Leadfoot Command object</a> that can be used to drive a remote environment. This value will be inherited from the parent suite. Only available to suites that are loaded from <a href="#option-functionalSuites">functionalSuites</a>.</td>
							</tr>
							<tr>
								<th scope="row">reporterManager <span class="versionBadge">3.0</span></th>
								<td>The event hub that can be used to send result data and other information to <a href="#reporter-overview">reporters</a>. This value will be inherited from the parent suite.</td>
							</tr>
							<tr>
								<th scope="row">sessionId</th>
								<td>A unique identifier for a remote environment session. This value will be inherited from the parent suite. Only available to suites that are loaded from <a href="#option-functionalSuites">functionalSuites</a>.</td>
							</tr>
							<tr>
								<th scope="row">skipped</th>
								<td>If a test is skipped, the reason for the skip will be available here.</td>
							</tr>
							<tr>
								<th scope="row">timeElapsed</th>
								<td>Time, in milliseconds, that the test took to execute. Only available once the test has finished running.</td>
							</tr>
							<tr>
								<th scope="row">timeout</th>
								<td>The maximum time, in milliseconds, that an asynchronous test can take to finish before it is considered timed out. Once the test function has finished executing, changing this value has no effect.</td>
							</tr>
						</table>

						<table class="api">
							<tr>
								<th>Method</th>
								<th>Description</th>
							</tr>
							<tr>
								<th scope="row">async(<br>&nbsp;&nbsp;timeout?: number,<br>&nbsp;&nbsp;numCallsUntilResolution?: number<br>): Deferred</th>
								<td>Makes the test asynchronous. This method is idempotent and will always return the same Deferred object. See <a href="#async-tests">asynchronous tests</a> for more information.</td>
							</tr>
							<tr>
								<th scope="row">skip(reason?: string): void</th>
								<td>Causes the test to be skipped.</td>
							</tr>
							<tr id="test-object-test">
								<th scope="row">test(): Promise&lt;void></th>
								<td>The test function for this test. If a Promise is returned, the test will wait until the Promise is resolved before passing. If the Promise rejects, the test will be considered failed and the error from the Promise will be used as the error for the Test.</td>
							</tr>
							<tr>
								<th scope="row">toJSON(): Object</th>
								<td>Returns an object that can be safely serialised to JSON. This method normally does not need to be called directly; <code>JSON.stringify</code> will use the <code>toJSON</code> method automatically if you try to serialise the Test object.</td>
							</tr>
							<tr>
								<th scope="row">run(): Promise&lt;void></th>
								<td>Runs the test. Returns a Promise that resolves to <code>undefined</code> after the test finishes successfully, or rejects with an error if the test failed.</td>
							</tr>
						</table>
					</article>

					<article>
						<div class="a" id="community"></div>
						<h2 data-id="community">Community</h2>

						<div class="a half" id="getting-help"></div>
						<h3 data-id="getting-help">Getting help</h3>

						<p>The Intern team wants to help people like you write tests more quickly and easily than ever before. As such, we offer two different ways you can get help with Intern:</p>

						<h4>Community support</h4>

						<p>The Intern community is available to assist you with basic questions, advice, and general guidance. There are two primary ways to get community support:</p>

						<ul>
							<li>Post on Stack Overflow using the tag <a href="http://stackoverflow.com/questions/ask?tags=intern">[intern]</a>. Please make sure to follow the <a href="http://stackoverflow.com/help/how-to-ask">Stack Overflow guidelines</a> when asking your question in order to have the greatest chance of receiving a response!</li>
							<li>Join us on IRC at <a href="irc://irc.freenode.net/intern">#intern on Freenode</a>. Please make sure to follow the rules outlined in <a href="https://rurounijones.github.io/blog/2009/03/17/how-to-ask-for-help-on-irc/">How to Ask for Help on IRC</a> when asking your question in order to have the greatest chance of receiving a response!</li>
						</ul>

						<h4>Commercial support</h4>

						<p>Some problems are too complicated, specific, time-sensitive, or confidential to be solved through free community support. In these cases, the creators of Intern, SitePen, offer <a href="http://www.sitepen.com/support/index.html">commercial support services</a> for you or your company. Commercial support has several advantages over community support:</p>

						<ul>
							<li>Guaranteed response</li>
							<li>24 hours maximum response time</li>
							<li>Priority bug fix and enhancement requests</li>
							<li>Total confidentiality for your next big idea</li>
							<li>Provides direct financial support for ongoing development of Intern</li>
						</ul>

						<p>If you aren’t sure if commercial support is right for you, we’re happy to take a few minutes to talk through your needs in greater detail. <a href="https://www.sitepen.com/site/contact.html">Get in touch</a> to schedule a time!</p>

						<div class="a half" id="contributing"></div>
						<h3 data-id="contributing">Contributing</h3>

						<p>We’re always excited to receive contributions from the community. If you think you’ve discovered a bug, want to submit a patch, or would like to request a new feature, take a look at our <a href="https://github.com/theintern/intern/blob/master/CONTRIBUTING.md">contribution guidelines on GitHub</a> to learn how you can contribute.</p>
					</article>

					<article>
						<div class="a" id="faq"></div>
						<h2 data-id="faq">FAQ</h2>

						<div class="a half" id="modifier-keys"></div>
						<h3 data-id="modifier-keys">How do I use modifier keys?</h3>

						<p>We recommend using Leadfoot to provide cross-browser consistency to the WebDriver API. To send <kbd class="bash">Shift</kbd> + Click to the browser you need to import the <kbd class="bash">leadfoot/keys</kbd> module, documented within <a href="https://theintern.github.io/leadfoot/module-leadfoot_keys.html">Leadfoot's API</a>:</p>

						<pre><code class="javascript">require([
	'intern!object',
	'chai!assert',
	'intern/dojo/node!leadfoot/keys'
], function (registerSuite, assert, keys) {
	registerSuite({
		name: 'test',
		'test1': function () {
			var remote = this.remote();
			return remote.get('testpage.html')
				.elementById('testLink')
				.pressKeys(keys.SHIFT)
				.clickElement()
				.pressKeys(keys.NULL)
				.end();
		}
	});
});</code></pre>

						<div class="a half" id="test-page-open"></div>
						<h3 data-id="test-page-open">How can I keep the test page open?</h3>

						<p>After the tests are done the browser is closed. This makes sense and is ideal for running automated tests but sometimes during test development you want to inspect the page to make adjustments or troubleshoot the cause of a failure. You can use Intern's <kbd class="bash">leaveRemoteOpen</kbd> command line option to keep the browser open after testing is complete. To use it just include it on the command line:</p>

						<pre><kbd class="bash">node node_modules/intern/runner/config=myPackage/test/intern leaveRemoteOpen</kbd></pre>

						<div class="a half" id="multiple-browsers"></div>
						<h3 data-id="multiple-browsers">How do I test with multiple browsers?</h3>

						<p>Once you've developed your tests and are satisfied with their quality and functionality, you may want to do additional local testing before using a remote testing service like Sauce Labs. In your Intern config, you can change the <kbd class="bash">browserName</kbd> value in <kbd class="bash">environments</kbd>, or you can specify multiple browsers:</p>

						<pre><code class="javascript">{
	environments: [
		{ browserName: 'chrome' },
		{ browserName: 'firefox' },
		{ browserName: 'internet explorer' },
		{ browserName: 'safari' }
	]
}</code></pre>

						<p>Selenium server includes drivers for Firefox and Safari, and drivers are available for <a href="https://sites.google.com/a/chromium.org/chromedriver/">Chrome</a> and <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/webdriver">IE11/Edge</a>. The <a href="https://github.com/seleniumhq/selenium/wiki">Selenium wiki</a> includes documentation for each driver. If you're using IEDriver or ChromeDriver, be sure the executables are in a directory in your environment's PATH.</p>

						<ol>
							<li>Download <a href="http://docs.seleniumhq.org/download/">Selenium server</a> (the standalone .jar)</li>
							<li>Launch Selenium server: <kbd class="bash">java -jar selenium-server-standalone-2.53.0.jar</kbd></li>
							<li>Run your Intern tests: <kbd class="bash">node node_modules/intern/runner config=myPackage/test/intern</kbd></li>
						</ol>
					</article>
				</main>
			</div>
		</div>
		<script src="css/main.min.js"></script>
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
			ga('create', 'UA-3242977-12', 'theintern.github.io');
			ga('send', 'pageview');
		</script>
	</body>
</html>
